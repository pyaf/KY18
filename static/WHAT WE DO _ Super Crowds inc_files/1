/* VERSION: Typescript */
(function (){
/**
 * GLOBAL WOVNio OBJECT
 * Dynamically loaded components must call the registerComponent
 * method to be available to Widget for loading
 *
 * Components in the scrip can make themselves available to
 * Widget by assigning themselves to the components object using
 * their component name as the key
 **/
// only run once
if (document.WOVNIO)
  return;

var components = {};


var Widget = function (components, options) {
  if (!options) options = {};
  //var that = this;
  var instance = {};
  var installedComponents = {};
  var cachedData = [];
  var DATA_TIMEOUT = 5000;

  document.WOVNIO = function () {
    var obj = {};
    obj.registerComponent = function (componentName, component) {
      components[componentName] = component;
      delete installedComponents[componentName];
      // dispatch load event
      var loadEvent = document.createEvent('Event');
      var eventName = componentName + 'Loaded';
      loadEvent.initEvent(eventName, true, true);
      document.dispatchEvent(loadEvent);
    };
    return obj;
  }();

  var insertedSrcs = [];
  var html = options.scriptTag || document.currentScript || function () {
    var scriptTags = document.getElementsByTagName('script');

    // this should return on the first loop iteration
    for (var i = scriptTags.length - 1; i >= 0; i--) {
      if (scriptTags[i].getAttribute('data-wovnio'))
        return scriptTags[i];
    }
    return scriptTags[scriptTags.length - 1];
    
  }();
  instance.tag = {
    html: html,
    getAttribute: function (attr) {
      attr = (typeof attr === 'string') ? attr : '';
      var hasAttr = html.hasAttribute ? html.hasAttribute(attr) : (html[attr] !== undefined);
      if (hasAttr) {
        return html.getAttribute(attr);
      }
      else {
        var rx = new RegExp(attr + '=([^&]*)', 'i');
        var match = (html.getAttribute('data-wovnio') || '').match(rx);
        return match ? (match[1] === 'false' ? false : match[1]) : '';
      }
    },
    /**
     * Insert an script tag with the specified src and attributes to the previous of the wovn script.
     * @param {String} srcAttr the src of the script
     * @param {Object} attrs additional attributes for the script
     */
    insertScriptBefore: function (srcAttr, attrs) {
      if (!srcAttr) return;
      var scriptEle   = document.createElement('script');
      scriptEle.type  = 'text/javascript';
      scriptEle.async = true;
      for (var name in attrs) if (attrs.hasOwnProperty(name)) scriptEle[name] = attrs[name];
      scriptEle.src   = srcAttr;

      html.parentNode.insertBefore(scriptEle, html);
      insertedSrcs.push(srcAttr);
      return scriptEle;
    },
    isScriptInserted: function (src) {
      // In tests, cannot call Utils' function because of Widget loading is faster than utils
      for (var i = 0; i < insertedSrcs.length; i++) {
        if (insertedSrcs[i] === src) {
          return true
        }
      }
      return false;
    },
    /**
     * Remove script tags containing the specified src
     * @param {String} src the src of the scripts
     */
    removeScript: function(src) {
      if (!src || !instance.tag.isScriptInserted(src)) return;
      insertedSrcs.splice(instance.c('Utils').indexOf(insertedSrcs, src), 1);
      var scripts = document.getElementsByTagName('script');
      for (var i = 0; i < scripts.length; ++i) {
        var script = scripts[i];
        if (script.getAttribute('src') === src && script.parentNode) script.parentNode.removeChild(script);
      }
    }
  };

  instance.isBackend = function() {
    return instance.tag.getAttribute('backend');
  };

  /**
   * Get component
   * @param componentName {String}
   * @returns component
   */
  var getComponent = function (componentName) {
    // Not use hasOwnProperty to speed up
    var component = installedComponents[componentName];
    if (component)
      return component;
    else if (components[componentName]) {
      installComponent(componentName);
      return installedComponents[componentName];
    }
    else {
      return null;
    }
  };

  var installComponent = function (componentName) {
    if (installedComponents[componentName] || typeof(components[componentName]) === 'undefined')
      return;

    if (typeof components[componentName] === 'function') {
      installedComponents[componentName] = new components[componentName](instance);
    }
    else {
      installedComponents[componentName] = components[componentName];
    }
  };

  instance.c = function (componentName) {
    return getComponent(componentName);
  };

  instance.isComponentLoaded = function (componentName) {
    return installedComponents.hasOwnProperty(componentName) || components.hasOwnProperty(componentName);
  };

  /**
   * Get components src
   *
   * @param {String} componentName
   * @param {Object} options
   * @param {String} options.location alternative of current location
   * @param {Boolean} options.failover if true, return URL for failover
   *
   * @return {String} src
   */
  var componentSrc = function(componentName, options) {
    if (!options) options = {};
    if (componentName === 'Data') {
      var key = instance.tag.getAttribute('key');
      if (!key) return null;
      var encodedLocation = getEncodedLocation(options['location']);
      var path = '/js_data/1/'+ key + '/?u=' + encodedLocation + '&version=1';
      var host = options.failover ? 'cdn.wovn.io' : 'wovn.global.ssl.fastly.net';
      return '//' + host + path;
    }
    else
      return options.failover ? null : ('//j.wovn.io/1/components/' + componentName);
  };

  /**
   * Get data src
   *
   * @param {Object} options
   * @param {String} options.location alternative of current location
   * @param {Boolean} options.failover if true, return URL for failover
   *
   * @return {String} src
   */
  var dataJsonSrc = function(options) {
    if (!options) options = {};
    var key = instance.tag.getAttribute('key');
    if (!key) return null;
    var encodedLocation = getEncodedLocation(options['location']);
    var path = '/js_data/json/1/'+ key + '/?u=' + encodedLocation + '&version=1';
    var host = options.failover ? 'cdn.wovn.io' : 'wovn.global.ssl.fastly.net';
    return '//' + host + path;
  };

  var savedDataJsonSrc = function() {
    var token = instance.tag.getAttribute('key');
    var session = encodeURIComponent(location.hash.match(/wovn\.editing=(.+)/)[1]);
    if (!token || !session) {
      return null;
    }

    var encodedLocation = getEncodedLocation(options['location']);
    var host = instance.c('Url').getApiHost();
    var url = host + 'js_saved_data/' + token + '?session_token=' + session + '&u=' + encodedLocation;
    return url;
  }

  var addLoadListener = function(componentName, callback) {
    var loadEvent = document.createEvent('Event');
    var eventName = componentName + 'Loaded';
    loadEvent.initEvent(eventName, true, true);
    if (document.addEventListener) {
      var handler = function() {
        document.removeEventListener(eventName, handler, false);
        callback.apply(this, arguments);
      };
      document.addEventListener(eventName, handler, false);
    } else if (document.attachEvent) {
      var handler = function() {
        document.detachEvent(eventName, handler);
        callback.apply(this, arguments);
      };
      document.attachEvent(eventName, handler);
    }
  };

  /**
   * Load a component
   *
   * @param {String} componentName
   * @param {Object} options
   * @param {Boolean} options.force if true, insert a script tag always
   * @param {Function} callback
   */
  instance.loadComponent = function (componentName, options, callback) {
    if (callback === undefined && typeof(options) === 'function') {
      callback = options;
      options = {};
    }
    options = options || {};

    if (typeof(callback) !== 'function') callback = function () {};

    // if this component is already loaded, call callback and return
    if (!options['force'] && instance.isComponentLoaded(componentName)) {
      setTimeout(callback, 0);
      return;
    }

    // setup load event
    var loaded = false;
    addLoadListener(componentName, function() {
      if (loaded) return;
      loaded = true;
      callback.apply(this, arguments);
    });

    var retried = false;
    var load = function() {
      var src = componentSrc(componentName, options);
      if (options['force'] || !instance.tag.isScriptInserted(src)) {
        var retry = function() {
          if (loaded || retried) return;
          retried = true;
          options.failover = true;
          load();
        };
        var attrs = {}
        // retry if the CDN returns an error.
        attrs.onerror = retry;
        attrs.onreadystatechange = function() {
          if (this.readyState === 'loaded' || this.readyState === 'complete') retry();
        };
        // retry if loading is timed out.
        setTimeout(retry, DATA_TIMEOUT);
      }
      instance.tag.insertScriptBefore(src, attrs);
    }
    load();
  };

  /**
   * Load data as JSON
   * @param {Function} callback
   */
  instance.loadDataJson = function(callback) {
    var src = dataJsonSrc();

    instance.c('Utils').sendRequestAsJson('GET', src, callback, errorFailover);

    function errorFailover(reason) {
      // Ignore 204 response (page doesn't exist or isn't published).
      if (reason && reason.status === 204) {
        return;
      }
      var src = dataJsonSrc({failover: true});
      instance.c('Utils').sendRequestAsJson('GET', src, callback, function() {})
    }
  };

  instance.loadSavedData = function(callback, errorCallback) {
    var src = savedDataJsonSrc();
    instance.c('Utils').sendRequestAsJson('GET', src, callback, errorCallback)
  };

  instance.loadComponents = function(componentNames, callbacks) {
    var newComponentNames = [];
    for (var i = 0; i < componentNames.length; ++i) {
      var componentName = componentNames[i];
      var callback = callbacks[componentName] || function() {};
      if (instance.isComponentLoaded(componentName)) {
        setTimeout(callback, 0);
      } else {
        addLoadListener(componentName, callback);
        newComponentNames.push(componentName);
      }
    }
    if (newComponentNames.length) instance.tag.insertScriptBefore(componentSrc(newComponentNames.join('+')));
  };

  /**
   * Load domain's option
   * @param {Function} callback called when succeed
   * @param {Function} errorCallback called when fail
   */
  instance.loadDomainOption = function(callback, errorCallback) {
    var key = instance.tag.getAttribute('key');
    if (!key) return;
    var retried = false;
    var loaded = false;
    var onsuccess = function(data, headers) {
      if (loaded) return;
      loaded = true;

      // In IE9, cannot access custom headers using XDomainRequest...
      var countryCode = null;
      if (headers) {
        // some browser need to access header by lowercase.
        var headerNames = ['Country-Code', 'country-code'];
        for (var i = 0; i < headerNames.length; i++) {
          var headerName = headerNames[i];
          if (headers[headerName]) {
            countryCode = headers[headerName];
            break;
          }
        }
        if (countryCode) {
          data['countryCode'] = countryCode;
        }
      }

      if (!countryCode && instance.c('Data').needsCountryCode(data)) {
        instance.loadCountryCode(function(jsonData) {
          if (jsonData && jsonData['countryCode']) {
            data['countryCode'] = jsonData['countryCode'];
          }
          callback(data);
        }, function() {})
        return
      }

      callback(data);
    };
    var onerror = function() {
      if (loaded) return;
      if (retried) {
        errorCallback.apply(this, arguments);
      } else {
        retried = true;
        load('cdn.wovn.io');
      }
    };
    var load = function(host) {
        var puny_host = instance.c('PunyCode').toASCII(getRealLocation().hostname)
        var option_url = '//' + host + '/domain/options/' + key + '?host=' + puny_host;
        instance.c('Utils').sendRequestAsJson('GET', option_url, onsuccess, onerror);
    };
    load('wovn.global.ssl.fastly.net');
    setTimeout(onerror, DATA_TIMEOUT);
  };

  instance.loadCountryCode = function(callback, errorCallback) {
    var loaded = false;
    var onsuccess = function() {
      loaded = true;
      callback.apply(this, arguments);
    };
    var onerror = function() {
      if (loaded) return;
      errorCallback.apply(this, arguments);
    };
    // Request must not go to CDN server
    var option_url = '//cdn.wovn.io/inspect/country';
    instance.c('Utils').sendRequestAsJson('GET', option_url, onsuccess, onerror);
    setTimeout(onerror, DATA_TIMEOUT);
  };

  /**
   * Get translated values
   * @param values {Array<String>} original values
   * @param callback
   * @param errorCallback
   */
  instance.loadTranslation = function(values, callback, errorCallback) {
    var key = instance.tag.getAttribute('key');
    if (!key) return;
    var url = '//ee.wovn.io/values/translate';
    var data = {
      srcs: values,
      defaultLang: instance.c('Lang').defaultCode(),
      token: key,
      host: getRealLocation().hostname
    }
    instance.c('Utils').postJsonRequest(url, data, callback, errorCallback);
  }

  instance.clearCacheData = function() {
    cachedData = []
  }

  instance.reloadData = function(callback) {
    var encodedLocation = getEncodedLocation();
    var cache = null;
    for (var i = 0; i < cachedData.length; ++i) {
      if (cachedData[i].encodedLocation === encodedLocation) {
        cache = cachedData[i];
        break;
      }
    }
    if (cache) {
      callback(cache.data);
    } else {
      instance.c('Interface').loadData(function(data) {
        cachedData.unshift({encodedLocation: encodedLocation, data: data});

        // To not use much memory.
        if (cachedData.length > 50) cachedData.pop();

        callback(data);
      });
    }
  };

  instance.removeComponentScript = function(componentName, options) {
    instance.tag.removeScript(componentSrc(componentName, options));
  };

  var destroyComponent = function(componentName) {
    if (typeof(installedComponents[componentName].destroy) === 'function') {
      installedComponents[componentName].destroy();
    }
  };

  instance.destroy = function () {
    for (componentName in installedComponents){
      if (installedComponents.hasOwnProperty(componentName)) destroyComponent(componentName);
    }
  };

  instance.reinstallComponent = function(componentName) {
    destroyComponent(componentName);
    installedComponents[componentName] = new components[componentName](instance);
  };

  instance.getBackendCurrentLang = function () {
    return instance.tag.getAttribute('currentLang');
  }

  /**
   * Gets the current location of the browser without the backend-inserted lang code
   *
   * @return {string} The unicode-safe location of this browser without the lang code
   */
  function getEncodedLocation (currentLocation) {
    // not all browsers handle unicode characters in the path the same, so we have this long mess to handle it
    // TODO: decodeURIcomponent doesnt handle the case where location has char like this: &submit=%8E%9F%82%D6%90i%82%DE (characters encoded in shift_jis)
    // adding unescape before it makes the error go away but doesnt fix the pb and creates pb for utf8 encode params
    if (!currentLocation)
      currentLocation = location;
    if (typeof(currentLocation) !== 'string') {
      var punyHost = instance.c('PunyCode').toASCII(currentLocation.host);
      currentLocation = currentLocation.protocol + '//' + punyHost + currentLocation.pathname + currentLocation.search;
    }

    var urlFormatter = instance.c('UrlFormatter').createFromUrl(currentLocation);
    currentLocation = urlFormatter.getNormalizedPageUrl(instance.tag.getAttribute('backend'), instance.tag.getAttribute('urlPattern'));
    return encodeURIComponent(currentLocation);
  }
  instance.getEncodedLocation = getEncodedLocation;

  /**
   * Gets the current location Object of the browser without the backend-inserted lang code
   *
   * @return {object} An object imitating the location, without the backend inserted lang code
   */
  function getRealLocation (currentLocation) {
    var fakeLocation = currentLocation || location;
    currentLocation = {}
    currentLocation.protocol = fakeLocation.protocol;
    currentLocation.search = fakeLocation.search;
    currentLocation.href = fakeLocation.href;
    currentLocation.host = fakeLocation.host;
    currentLocation.port = fakeLocation.port;
    currentLocation.hostname = fakeLocation.hostname;
    currentLocation.origin = fakeLocation.origin;
    currentLocation.pathname = fakeLocation.pathname;

    if (instance.tag.getAttribute('backend')) {
      var langIdentifier = instance.c('Lang').getBackendLangIdentifier();
      switch (instance.tag.getAttribute('urlPattern')) {
        case 'query':
          currentLocation.search = currentLocation.search.replace(new RegExp('(\\?|&)wovn=' + langIdentifier + '(&|$)'), '$1').replace(/(\?|&)$/, '');
          currentLocation.href = currentLocation.href.replace(new RegExp('(\\?|&)wovn=' + langIdentifier + '(&|$)'), '$1').replace(/(\?|&)$/, '');
          break;
        case 'subdomain':
          currentLocation.host = currentLocation.host.replace(new RegExp('^' + langIdentifier + '\\.', 'i'), '');
          currentLocation.hostname = currentLocation.hostname.replace(new RegExp('^' + langIdentifier + '\\.', 'i'), '');
          currentLocation.href = currentLocation.href.replace(new RegExp('//' + langIdentifier + '\\.', 'i'), '//');
          currentLocation.origin = currentLocation.origin.replace(new RegExp('//' + langIdentifier + '\\.', 'i'), '//');
          break;
        case 'path':
          currentLocation.href = currentLocation.href.replace(new RegExp('(//[^/]+)/' + langIdentifier + '(/|$)'), '$1/');
          currentLocation.pathname = currentLocation.pathname.replace(new RegExp('/' + langIdentifier + '(/|$)'), '/');
      }
    }
    return currentLocation;
  }
  instance.getRealLocation = getRealLocation;

  return instance;

};

var widget = Widget(components);

// old widget compatibility
document.appendM17nJs = function (res) {
  var components = {};
  components['Data'] = function (widget) {
    var that = this;
    var data = res;

    this.get = function () {
      return data;
    };

    this.set = function (setData) {
      data = setData;
    };

    this.getLang = function () {
      return data['language'];
    };

    this.getUserId = function () {
      return data['user_id'];
    };

    this.getPageId = function () {
      return data['id'];
    };

    this.getPublishedLangs = function () {
      return data['published_langs'];
    };

    this.getOptions = function () {
      return data['widgetOptions'];
    };

    this.dynamicValues = function () {
      return data['dynamic_values'] || (that.getOptions() || {})['dynamic_values'] || false;
    };

  };

  for (var componentName in components){if(components.hasOwnProperty(componentName)) {
    document.WOVNIO.registerComponent(componentName, components[componentName]);
  }}
};


// Original Cookie code from http://developers.livechatinc.com/blog/setting-cookies-to-subdomains-in-javascript/
if (typeof(components) === 'undefined') var components = {};
components['Cookie'] = function (widget) {
  var that = this;

  this.set = function (name, value, days, host) {
    if (name === '') return;
    host = host === undefined ? (location.hostname || 'wovn.io') : host;
    var cookie = name + '=' + (value === null ? '' : value) + '; path=/';
    if (days) {
      var date = new Date();
      date.setTime(date.getTime()+(days*24*60*60*1000));
      cookie += "; expires=" + date.toGMTString();
    }
    var lastCookie = null;
    var setCookie = function(domain) {
      lastCookie = cookie + (domain ? ('; domain=' + domain) : '');
      document.cookie = lastCookie;
    };
    if (host.split('.').length === 1) {
      // no "." in a domain - it's localhost or something similar
      setCookie();
    } else {
      // Remember the cookie on all subdomains.
      //
      // Start with trying to set cookie to the top domain.
      // (example: if user is on foo.com, try to set
      //  cookie to domain ".com")
      //
      // If the cookie will not be set, it means ".com"
      // is a top level domain and we need to
      // set the cookie to ".foo.com"
      var domainParts = host.split('.');
      domainParts.shift();
      var domain = '.'+domainParts.join('.');
      setCookie(domain);
      // check if cookie was successfuly set to the given domain
      // (otherwise it was a Top-Level Domain)
      if (that.get(name) == null || that.get(name) != value) {
        // append "." to current domain
        domain = '.'+host;
        setCookie(domain);
        // check if cookie was successfuly set to the given domain
        // (otherwise it was maybe an ip address)
        if (that.get(name) == null || that.get(name) != value) {
          // use domain as-is
          setCookie(host);
        }
      }
    }
    return lastCookie;
  };

  this.get = function (name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for (var i=0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0)==' ') {
        c = c.substring(1,c.length);
      }

      if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
    }
    return null;
  };

  this.erase = function (name) {
    that.set(name, null, -1);
    that.set(name, null, -1, ''); // also erase no domain cookie
  };
};

if (typeof components === 'undefined') var components = {};
components['PunyCode'] = function () {
  // Modified from https://github.com/bestiejs/punycode.js

  // Copyright Mathias Bynens <https://mathiasbynens.be/>
  // https://github.com/bestiejs/punycode.js/blob/master/LICENSE-MIT.txt
  'use strict';

  /** Highest positive signed 32-bit float value */

  var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

  /** Bootstring parameters */
  var base = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128; // 0x80
  var delimiter = '-'; // '\x2D'

  /** Regular expressions */
  var regexNonASCII = /[^\x20-\x7E]/; // unprintable ASCII chars + non-ASCII chars
  var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

  /** Error messages */
  var errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
  };

  /** Convenience shortcuts */
  var baseMinusTMin = base - tMin;
  var floor = Math.floor;
  var stringFromCharCode = String.fromCharCode;

  /*--------------------------------------------------------------------------*/

  /**
   * A generic error utility function.
   * @private
   * @param {String} type The error type.
   * @returns {Error} Throws a `RangeError` with the applicable error message.
   */
  function error(type) {
    throw new RangeError(errors[type]);
  }

  /**
   * A generic `Array#map` utility function.
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function that gets called for every array
   * item.
   * @returns {Array} A new array of values returned by the callback function.
   */
  function map(array, fn) {
    var result = [];
    var length = array.length;
    while (length--) {
      result[length] = fn(array[length]);
    }
    return result;
  }

  /**
   * A simple `Array#map`-like wrapper to work with domain name strings or email
   * addresses.
   * @private
   * @param {String} domain The domain name or email address.
   * @param {Function} callback The function that gets called for every
   * character.
   * @returns {Array} A new string of characters returned by the callback
   * function.
   */
  function mapDomain(string, fn) {
    var parts = string.split('@');
    var result = '';
    if (parts.length > 1) {
      // In email addresses, only the domain name should be punycoded. Leave
      // the local part (i.e. everything up to `@`) intact.
      result = parts[0] + '@';
      string = parts[1];
    }
    // Avoid `split(regex)` for IE8 compatibility. See #17.
    string = string.replace(regexSeparators, '\x2E');
    var labels = string.split('.');
    var encoded = map(labels, fn).join('.');
    return result + encoded;
  }

  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   * @see `punycode.ucs2.encode`
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode.ucs2
   * @name decode
   * @param {String} string The Unicode input string (UCS-2).
   * @returns {Array} The new array of code points.
   */
  function ucs2decode(string) {
    var output = [];
    var counter = 0;
    var length = string.length;
    while (counter < length) {
      var value = string.charCodeAt(counter++);
      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // It's a high surrogate, and there is a next character.
        var extra = string.charCodeAt(counter++);
        if ((extra & 0xFC00) == 0xDC00) {
          // Low surrogate.
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // It's an unmatched surrogate; only append this code unit, in case the
          // next code unit is the high surrogate of a surrogate pair.
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }

  /**
   * Converts a digit/integer into a basic code point.
   * @see `basicToDigit()`
   * @private
   * @param {Number} digit The numeric value of a basic code point.
   * @returns {Number} The basic code point whose value (when used for
   * representing integers) is `digit`, which needs to be in the range
   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
   * used; else, the lowercase form is used. The behavior is undefined
   * if `flag` is non-zero and `digit` has no uppercase form.
   */
  var digitToBasic = function digitToBasic(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };

  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * https://tools.ietf.org/html/rfc3492#section-3.4
   * @private
   */
  var adapt = function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  };

  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   * @memberOf punycode
   * @param {String} input The string of Unicode symbols.
   * @returns {String} The resulting Punycode string of ASCII-only symbols.
   */
  var encode = function encode(input) {
    var output = [];

    // Convert the input in UCS-2 to an array of Unicode code points.
    input = ucs2decode(input);

    // Cache the length.
    var inputLength = input.length;

    // Initialize the state.
    var n = initialN;
    var delta = 0;
    var bias = initialBias;

    // Handle the basic code points.
    try {
      for (var i = 0; i < input.length; i++) {
        var currentValue = input[i];

        if (currentValue < 0x80) {
          output.push(stringFromCharCode(currentValue));
        }
      }
    } catch (err) {
      // ignore errors
    }

    var basicLength = output.length;
    var handledCPCount = basicLength;

    // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.

    // Finish the basic string with a delimiter unless it's empty.
    if (basicLength) {
      output.push(delimiter);
    }

    // Main encoding loop:
    while (handledCPCount < inputLength) {

      // All non-basic code points < n have been handled already. Find the next
      // larger one:
      var m = maxInt;
      try {

        for (var i = 0; i < input.length; i++) {
          var currentValue = input[i];

          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
      } catch (err) {
        // ignore errors
      }

      var handledCPCountPlusOne = handledCPCount + 1;
      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error('overflow');
      }

      delta += (m - n) * handledCPCountPlusOne;
      n = m;

      try {
        for (var i = 0; i < input.length; i++) {
          var currentValue = input[i];

          if (currentValue < n && ++delta > maxInt) {
            error('overflow');
          }
          if (currentValue == n) {
            // Represent delta as a generalized variable-length integer.
            var q = delta;
            for (var k = base;; /* no condition */k += base) {
              var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) {
                break;
              }
              var qMinusT = q - t;
              var baseMinusT = base - t;
              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
              q = floor(qMinusT / baseMinusT);
            }

            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
      } catch (err) {
        // ignore errors
      }

      ++delta;
      ++n;
    }
    return output.join('');
  };

  /**
   * Converts a Unicode string representing a domain name or an email address to
   * Punycode. Only the non-ASCII parts of the domain name will be converted,
   * i.e. it doesn't matter if you call it with a domain that's already in
   * ASCII.
   * @memberOf punycode
   * @param {String} input The domain name or email address to convert, as a
   * Unicode string.
   * @returns {String} The Punycode representation of the given domain name or
   * email address.
   */
  this.toASCII = function(input) {
    return mapDomain(input, function (string) {
      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
    });
  };
};
// Original Cookie code from http://developers.livechatinc.com/blog/setting-cookies-to-subdomains-in-javascript/
if (typeof(components) === 'undefined') var components = {};
components['Lang'] = function (widget) {
  var that = this;
  var langHash = {"ar":{"name":"العربية","code":"ar","en":"Arabic"},"bg":{"name":"Български","code":"bg","en":"Bulgarian"},"zh-CHS":{"name":"简体中文","code":"zh-CHS","en":"Simp Chinese"},"zh-CHT":{"name":"繁體中文","code":"zh-CHT","en":"Trad Chinese"},"da":{"name":"Dansk","code":"da","en":"Danish"},"nl":{"name":"Nederlands","code":"nl","en":"Dutch"},"en":{"name":"English","code":"en","en":"English"},"fi":{"name":"Suomi","code":"fi","en":"Finnish"},"fr":{"name":"Français","code":"fr","en":"French"},"de":{"name":"Deutsch","code":"de","en":"German"},"el":{"name":"Ελληνικά","code":"el","en":"Greek"},"he":{"name":"עברית","code":"he","en":"Hebrew"},"id":{"name":"Bahasa Indonesia","code":"id","en":"Indonesian"},"it":{"name":"Italiano","code":"it","en":"Italian"},"ja":{"name":"日本語","code":"ja","en":"Japanese"},"ko":{"name":"한국어","code":"ko","en":"Korean"},"ms":{"name":"Bahasa Melayu","code":"ms","en":"Malay"},"my":{"name":"ဗမာစာ","code":"my","en":"Burmese"},"ne":{"name":"नेपाली भाषा","code":"ne","en":"Nepali"},"no":{"name":"Norsk","code":"no","en":"Norwegian"},"pl":{"name":"Polski","code":"pl","en":"Polish"},"pt":{"name":"Português","code":"pt","en":"Portuguese"},"ru":{"name":"Русский","code":"ru","en":"Russian"},"es":{"name":"Español","code":"es","en":"Spanish"},"sv":{"name":"Svensk","code":"sv","en":"Swedish"},"th":{"name":"ภาษาไทย","code":"th","en":"Thai"},"hi":{"name":"हिन्दी","code":"hi","en":"Hindi"},"tr":{"name":"Türkçe","code":"tr","en":"Turkish"},"uk":{"name":"Українська","code":"uk","en":"Ukrainian"},"vi":{"name":"Tiếng Việt","code":"vi","en":"Vietnamese"}};
  var defaultCode = null;
  var secondaryCode = null;
  var docLangSet = false;
  var docLang;

  /**
   * An object of language aliases passed through snippet options
   * from backend.
   * 
   * key => lang code
   * value => lang alias
   * 
   */
  var langCodeAliases = function () {
    var langCodeAliasesStr = widget.tag.getAttribute('langCodeAliases');
    var langCodeAliasesObject = langCodeAliasesStr !== '' ? widget.c('Utils').parseJSON(langCodeAliasesStr) : {};
    for (langCode in langCodeAliasesObject){if(langCodeAliasesObject.hasOwnProperty(langCode)) {
      if (!langHash[langCode] || langCodeAliasesObject[langCode] === '') {
        delete langCodeAliasesObject[langCode];
      }
    }}
    return langCodeAliasesObject;
  }();

  /**
   * Returns the language object for the given code, name, English name, or alias
   *
   * @param {String|Object} langName A code, name, English name, alias,
   *                         or object containing a code.
   *
   * @returns {Object} The language object who's code, name, English name, or alias
   *                    matches the param. If no languages match, returns null.
   */
  this.get = function(langName) {
    if (langName.code) var langName = langName.code
    if (typeof langName !== 'string') return null;
      langName = langName.toLowerCase();
    for (langCode in langHash){if(langHash.hasOwnProperty(langCode)) {
      if (langName === langHash[langCode].name.toLowerCase() || langName === langHash[langCode].code.toLowerCase() || langName === langHash[langCode].en.toLowerCase())
        return langHash[langCode];
    }}
    for (langCode in langCodeAliases){if(langCodeAliases.hasOwnProperty(langCode)) {
      if (langName === langCodeAliases[langCode]) {
        return langHash[langCode];
      }
    }}
    return null;
  };

  /**
   * Normalizes language codes to the iso 6391
   * reference: https://support.google.com/webmasters/answer/189077?hl=en
   * @param langCode {String} The language code to be normalized
   * @returns {String} The normalized language code
   */
  this.iso6391Normalization = function(langCode) {
    return langCode.replace(/zh-CHT/i, 'zh-Hant').replace(/zh-CHS/i, 'zh-Hans');
  };

  this.getCode = function (langName) {
    var lang = this.get(langName);
    return lang && lang.code;
  };

  this.getCodes = function() {
    var codes = [];
    for (var code in langHash) if (langHash.hasOwnProperty(code)) codes.push(code);
    return codes;
  };

  this.isCode = function(code) {
    return langHash.hasOwnProperty(code);
  };

  this.isAlias = function(candidateAlias) {
    for (langCode in langCodeAliases){if(langCodeAliases.hasOwnProperty(langCode)) {
      if (candidateAlias === langCodeAliases[langCode]) {
        return true;
      }
    }}
    return false;
  };


  this.hasAlias = function (langCode) {
    return langCodeAliases[langCode] && (langCodeAliases[langCode] !== langCode)
  }

  this.isCaseInsensitiveCode = function(code) {
    for (var langCode in langHash) if (langHash.hasOwnProperty(langCode) && code.toLowerCase() === langCode.toLowerCase()) return true;
    return false;
  };

  this.isCaseInsensitiveAlias = function(candidateAlias) {
    for (langCode in langCodeAliases){if(langCodeAliases.hasOwnProperty(langCode)) {
      if (candidateAlias.toLowerCase() === langCodeAliases[langCode].toLowerCase()) {
        return true;
      }
    }}
    return false;
  };

  this.setDefaultCodeAndRecomputeSecondaryCode = function(code) {
    defaultCode = code;
    secondaryCode = computeSecondaryCode();
  };

  this.defaultCode = function () {
    if (!defaultCode) {
      // widget.c('Data').getLang() returns null if page-data is not loaded
      defaultCode = (widget.tag.getAttribute('backend') && widget.tag.getAttribute('defaultLang')) || widget.c('Data').getLang();
      return defaultCode || 'en';
    }
    return defaultCode;
  };

  this.getSecondaryCode = function () {
    if (secondaryCode === null) {
      secondaryCode = computeSecondaryCode();
    }
    return secondaryCode;
  }

  var computeSecondaryCode = function () {
    var code = widget.c('Data').getSecondaryLang();
    var translatableLangs = widget.c('Data').getTranslatableLangs()

    if (!code || widget.c('Utils').indexOf(translatableLangs, code) === -1) {
      code = that.defaultCode();
    }

    return code;
  }

  this.missingAutoTranslateLangs = function () {
    var langs = widget.c('Data').getTranslatableLangs();
    var autoLangs = widget.c('Data').getAutoTranslateLangs();
    return widget.c('Utils').setComplement(autoLangs, langs).length > 0;
  }

  this.missingAutoPublishLangs = function () {
    var langs = widget.c('Data').getTranslatableLangs();
    var autoLangs = widget.c('Data').getAutoPublishLangs();
    return widget.c('Utils').setComplement(autoLangs, langs).length > 0;
  }

  /**
   * Set docLang of the page.
   * @param  {string} newLangCode - docLang
   * @return {void}
   */
  this.setDocLang = function (newLangCode) {
    // Get the oldLangCode, but if this is the first time the docLang has been set,
    // getDocLang returns the newLangCode so we use the defaultCode
    var oldLangCode = docLangSet ? that.getDocLang() : that.defaultCode();
    newLangCode = newLangCode || that.getDocLang();

    var translatableLangs = widget.c('Data').getTranslatableLangs();
    if (widget.c('Utils').includes(translatableLangs, newLangCode) === false) {
      return
    }

    (document.getElementsByTagName('html')[0]).setAttribute('lang', that.iso6391Normalization(newLangCode));
    // backend case AND lang path case
    var langPath = widget.c('Data').getOptions().lang_path;
    if ((langPath === 'query' || langPath === 'path' || (widget.isBackend() && widget.tag.getAttribute('urlPattern'))) && widget.c('Url').getLangCode() !== newLangCode) {
      widget.c('Url').changeUrl(newLangCode);
      //return;
    }

    widget.c('LangCookie').set(newLangCode);

    // swap vals
    widget.c('DomAuditor').swapVals(newLangCode);

    docLang = newLangCode;

    // only dispatch event if the lang code has changed
    if (oldLangCode !== newLangCode) {
      setTimeout(function () {widget.c('Api').dispatchLangChangedEvent();}, 0);
    }
    docLangSet = true;
  };

  this.setDocLangWithoutSwap = function (newLangCode) {
    // Get the oldLangCode, but if this is the first time the docLang has been set,
    // getDocLang returns the newLangCode so we use the defaultCode
    var oldLangCode = docLangSet ? that.getDocLang() : that.defaultCode();
    newLangCode = newLangCode || that.getDocLang();

    var translatableLangs = widget.c('Data').getTranslatableLangs();
    if (widget.c('Utils').includes(translatableLangs, newLangCode) === false) {
      return
    }

    (document.getElementsByTagName('html')[0]).setAttribute('lang', that.iso6391Normalization(newLangCode));
    // backend case AND lang path case
    var langPath = widget.c('Data').getOptions().lang_path;
    if ((langPath === 'query' || langPath === 'path' || (widget.isBackend() && widget.tag.getAttribute('urlPattern'))) && widget.c('Url').getLangCode() !== newLangCode) {
      widget.c('Url').changeUrl(newLangCode);
    }

    widget.c('LangCookie').set(newLangCode);

    docLang = newLangCode;

    // only dispatch event if the lang code has changed
    if (oldLangCode !== newLangCode) {
      setTimeout(function () {widget.c('Api').dispatchLangChangedEvent();}, 0);
    }
    docLangSet = true;
  };

  var convertedCodes;
  /**
   * Checks if a given language code is valid for the page.
   *
   * @param {String} langCode The language code to check.
   *
   * @returns {Boolean} True if the language code is valid for the page,
   *                    otherwise false.
   */
  function isValidLangCode (langCode) {
    if(!convertedCodes) {
      convertedCodes = {};
      var convertedLangs = that.getConvertedLangs();
      for(var i = 0; i < convertedLangs.length; i++) {
        convertedCodes[convertedLangs[i].code] = true;
      }
    }

    return convertedCodes[langCode] || false;
  }

  /**
   * cache for tag's currentLang
   */
  var currentLangOfWidgetTag = widget.getBackendCurrentLang()
  /**
   * Get the actual language of the page.
   * In contrast to getDocLang, getActualLang always provides the current
   * language of the page. Indeed getDocLang provides the language that should
   * be displayed, whether it is already displayed or not.
   * For instance: If a Japanese page is loaded with cookie set to English
   * language, getDocLang answers English (even if Japanese text has not been
   * swapped to English yet) while getActualLang answers Japanese.
   *
   * @returns {String} The actual language code of the page (the one of its
   *                   text).
   */
  this.getActualLang = function () {
    if (docLangSet) {
      return that.getDocLang();
    } else {
      // if backend, then get backend language, because it has already swapped
      // the values
      if (widget.isBackend()) {
        if (isValidLangCode(currentLangOfWidgetTag)) {
          return currentLangOfWidgetTag;
        }
      }
      return that.defaultCode();
    }
  }

  /**
   * Get docLang of the page.
   * @return {string} docLang
   */
  this.getDocLang = function () {
    return docLang || function () {
      var defaultLang = that.defaultCode();
      var secondaryLang = that.getSecondaryCode();

      // For Data Highlighter of Google Search Console.
      if (widget.c('Agent').isDataHighlighter()) {
        if (widget.isBackend()) {
          docLang = widget.c('Url').getLangCode();
          if (!isValidLangCode(docLang)) {
            docLang = defaultLang;
          }
        } else {
          docLang = defaultLang;
        }
        return docLang;
      }

      // if backend, trust the backend
      if (widget.tag.getAttribute('backend')) {
        if (!widget.c('LangCookie').get()) {
          var browserLang = that.getBrowserLang();
          if (isValidLangCode(browserLang)) {
            docLang = browserLang;
          }
        }
        if (!docLang) {
          var currentLang = widget.getBackendCurrentLang();
          if (isValidLangCode(currentLang)) {
            docLang = currentLang;
          }
        }
        if(!docLang) {
          docLang = secondaryLang;
        }
        return docLang;
      }

      var urlLang = widget.c('Url').getLangCode();
      if (defaultLang !== urlLang && isValidLangCode(urlLang)) {
        docLang = urlLang;
      }
      if (!docLang) {
        var cookieLang = widget.c('LangCookie').get();
        if(isValidLangCode(cookieLang)) {
          docLang = cookieLang;
        }
      }
      if (!docLang) {
        var browserLang = that.getBrowserLang();
        if (isValidLangCode(browserLang)) {
          docLang = browserLang;
        }
      }
      if (!docLang) {
        docLang = secondaryLang;
      }

      return docLang;
    }();
  };


  /**
   * Get browser language.
   */
  this.getBrowserLang = function  () {
    // Chrome language settings is set in window.navigator.languages, not window.navigator.language.
    var browserLang = (window.navigator.languages && window.navigator.languages[0]) ||
                       window.navigator.language ||
                       window.navigator.userLanguage ||
                       window.navigator.browserLanguage;

    return this.browserLangCodeToWidgetLangCode(browserLang);
  }

  this.browserLangCodeToWidgetLangCode = function (langCode) {
    var widgetLangCodes = that.getCodes();
    var code = null;

    switch (langCode.toLowerCase()) {
      case 'zh-tw':
        code = 'zh-CHT';
        break;
      case 'zh-cn':
      case 'zh':
        code = 'zh-CHS';
        break;
      case 'iw':
        code = 'he';
        break;
      default:
        code = langCode;
    }

    if(code) {
      for (var i = 0; i < widgetLangCodes.length; i++) {
        if (widgetLangCodes[i] === code) {
          return widgetLangCodes[i];
        }
        else {
          var re = new RegExp('^' + widgetLangCodes[i], 'i');
          if (code.match(re))
            return widgetLangCodes[i];
        }
      }
    }
    return null;
  }

  this.getConvertedLangs = function() {
    return widget.c('Data').get().convert_langs;
  };

  this.addConvertedLang = function(lang) {
    var langs = that.getConvertedLangs();
    if (!langs) {
      langs = [];
      widget.c('Data').get().convert_langs = langs;
    }
    lang = that.get(lang);
    for (var i = 0; i < langs.length; ++i) {
      if (langs[i].code === lang.code) return;
    }
    langs.push(lang);
  };

  /**
   * Returns the language identifier for the given language code.
   * The language identifier is the string that is displayed in the
   * domain, path, or query.
   *
   * @param {String} langCode A language code
   *
   * @returns {String} The custom identifier if it is configured on
   *                    backend, otherwise the langCode itself.
   */
  this.getLangIdentifier = function (langCode) {
    if (!widget.isBackend()) return that.getCode(langCode);

    return langCodeAliases[langCode] || that.getCode(langCode);
  };

  this.getBackendLangIdentifier = function () {
    var lang = widget.getBackendCurrentLang();
    return this.getLangIdentifier(lang);
  }
};

if (typeof(components) === 'undefined') var components = {};
components['LangCookie'] = function (widget) {
  var SELECTED_LANG_COOKIE_NAME = 'wovn_selected_lang';
  var REGISTERED_TIME_COOKIE_NAME = 'wovn_selected_lang_set_time';
  var TIME_EXPIRE_BEFORE = 0;

  this.set = function (langCode) {
    setCookieRegisteredTime();
    widget.c('Cookie').set(SELECTED_LANG_COOKIE_NAME, langCode, 365);
  }

  this.get = function () {
    migrateOldCookie();

    if (isCookieExpired()) {
      return null;
    }

    return widget.c('Cookie').get(SELECTED_LANG_COOKIE_NAME);
  }

  this.erase = function () {
    widget.c('Cookie').erase(SELECTED_LANG_COOKIE_NAME);
  }

  function migrateOldCookie() {
    // "wovn_selected_lang_2017v1" is deprecated
    var oldCookieName = 'wovn_selected_lang_2017v1';
    var oldCookieLangCode = widget.c('Cookie').get(oldCookieName);
    if (oldCookieLangCode) {
      widget.c('Cookie').erase(oldCookieName);
      setLangToCookie(oldCookieLangCode);
    }
  }

  function setLangToCookie (langCode) {
    setCookieRegisteredTime();
    widget.c('Cookie').set(SELECTED_LANG_COOKIE_NAME, langCode, 365);
  }

  function setCookieRegisteredTime () {
    widget.c('Cookie').set(REGISTERED_TIME_COOKIE_NAME, new Date().getTime(), 365);
  }

  function isCookieExpired () {
    var cookieSetTime = widget.c('Cookie').get(REGISTERED_TIME_COOKIE_NAME);
    if (!cookieSetTime) {
      return true;
    }
    return cookieSetTime < TIME_EXPIRE_BEFORE;
  }

}

if (typeof(components) === 'undefined') var components = {};
components['Url'] = function(widget) {
  var that = this;

  var isOptionLoaded = false;

  var _currentOptions = {
    urlPattern: null
  };

  var imageFilePattern = /^(https?:\/\/)?.*(\.((?!jp$)jpe?g?|bmp|gif|png|btif|tiff?|psd|djvu?|xif|wbmp|webp|p(n|b|g|p)m|rgb|tga|x(b|p)m|xwd|pic|ico|fh(c|4|5|7)?|xif|f(bs|px|st)))(?=([\?#&].*$|$))/i
  var audioFilePattern = /^(https?:\/\/)?.*(\.(mp(3|2)|m(p?2|3|p?4|pg)a|midi?|kar|rmi|web(m|a)|aif(f?|c)|w(ma|av|ax)|m(ka|3u)|sil|s3m|og(a|g)|uvv?a))(?=([\?#&].*$|$))/i
  var videoFilePattern = /^(https?:\/\/)?.*(\.(m(x|4)u|fl(i|v)|3g(p|2)|jp(gv|g?m)|mp(4v?|g4|e?g)|m(1|2)v|ogv|m(ov|ng)|qt|uvv?(h|m|p|s|v)|dvb|mk(v|3d|s)|f4v|as(x|f)|w(m(v|x)|vx)))(?=([\?#&].*$|$))/i
  var docFilePattern = /^(https?:\/\/)?.*(\.(zip|tar|ez|aw|atom(cat|svc)?|(cc)?xa?ml|cdmi(a|c|d|o|q)?|epub|g(ml|px|xf)|jar|js|ser|class|json(ml)?|do(c|t)m?|xps|pp(a|tx?|s)m?|potm?|sldm|mp(p|t)|bin|dms|lrf|mar|so|dist|distz|m?pkg|bpk|dump|rtf|tfi|pdf|pgp|apk|o(t|d)(b|c|ft?|g|h|i|p|s|t)))(?=([\?#&].*$|$))/i

  /**
   * Get current options
   * @returns {{}}
   */
  function getCurrentOptions() {
    if (isOptionLoaded) {
      return _currentOptions;
    }
    if (widget.tag.getAttribute('urlPattern')) {
      _currentOptions.urlPattern = widget.tag.getAttribute('urlPattern');
      isOptionLoaded = true;
    } else {
      var options = widget.c('Data').getOptions();
      if (options && options.lang_path) {
        switch (options.lang_path) {
          case 'query':
            _currentOptions.urlPattern = 'query';
            break;
          case 'path':
            _currentOptions.urlPattern = 'path';
            break;
          case 'subdomain':
            _currentOptions.urlPattern = 'subdomain';
            break;
        }
        isOptionLoaded = true;
      }
    }
    return _currentOptions;
  }

  /**
   * Get current option
   * @returns {{}}
   */
  this.getOptions = function () {
    return getCurrentOptions();
  };

  /**
   * Replace current option
   * @param {{}} options
   */
  this.setOptions = function(options) {
    var currentOptions = getCurrentOptions();
    for (var key in options) if (currentOptions.hasOwnProperty(key)) currentOptions[key] = options[key];
  };

  /**
   * Get current language code
   * @param {string} url
   * @returns {string}
   */
  this.getLangCode = function(url) {
    url = this.getLocation(url || location.href).href;
    var match = null;
    var rx;
    var currentOptions = getCurrentOptions();

    switch (currentOptions.urlPattern) {
      case 'query':
        rx = new RegExp('((\\?.*&)|\\?)wovn=([^#&]+)(#|&|$)');
        match = url.match(rx);
        match = match ? match[3] : null;
        break;
      case 'hash':
        rx = new RegExp('((\\#.*&)|\\#)wovn=([^&]+)(&|$)');
        match = url.match(rx);
        match = match ? match[3] : null;
        break;
      case 'subdomain':
        rx = new RegExp('://([^.]+)\.');
        match = url.match(rx);
        match = match && (widget.c('Lang').isCaseInsensitiveCode(match[1]) || widget.c('Lang').isCaseInsensitiveAlias(match[1])) ? match[1] : null;
        break;
      case 'path':
        var sitePrefix = widget.c('Config').getSitePrefixPath();
        if (sitePrefix) {
          rx = new RegExp('(://[^/]+|^)/' + sitePrefix + '/([^/#?]+)');
        } else {
          rx = new RegExp('(://[^/]+|^)/([^/#?]+)');
        }

        match = url.match(rx);
        match = match && (widget.c('Lang').isCode(match[2]) || widget.c('Lang').isAlias(match[2])) ? match[2] : null;
        break;
    }
    if (match) {
      var langCode = widget.c('Lang').getCode(match);
      if (langCode) {
        if (!widget.c('Lang').hasAlias(langCode) || (match === widget.c('Lang').getLangIdentifier(langCode))) {
          return langCode;
        }
      }
    }
    return widget.c('Lang').defaultCode();
  };

  /**
   * Detects the protocol used for a given URL.
   *
   * @param {String} url The URL to process.
   *
   * @return {String} The protocol of the given URL.
   */
  this.getProtocol = function(url) {
    var protocolMatching = /^([a-zA-Z]+):/.exec(url);

    if (protocolMatching && protocolMatching[1]) {
      return protocolMatching[1].toLowerCase();
    }

    return location.protocol.replace(/:$/, '').toLowerCase();
  }

  this.getDomainPort = function(url) {
    var match = /:\/\/(.[^\/]+)\/?/.exec(url);
    if (match) {
      return match[1];
    } else {
      return '';
    }
  };

  this.getFlags = function (url) {
    url = url || location.href;
    var hash = url.match(/#[^?]*$/);
    hash = hash ? hash[0] : '#';

    var match = hash.match(/(^|#|&)wovn=([^#&]*)(&|#|$)/);
    if (!match || match.length < 3) return [];
    // remove empty flags in the middle or beginning/ending of string
    var match = match[2].replace(/,(,+)/g, ',').replace(/^,|,$/g, '');
    if (match === '') return [];

    return match.split(',');
  };

  this.hasFlag = function (flag, url) {
    url = url || location.href;

    var flags = that.getFlags(url);

    return widget.c('Utils').indexOf(flags, flag) !== -1;
  };

  this.isFilePathURI = function(url) {

    return url && (url.match(imageFilePattern) ||
      url.match(audioFilePattern) ||
      url.match(videoFilePattern) ||
      url.match(docFilePattern))
  }

  this.getUrl = function(lang, url) {
    url = url || location.href;
    var protocol = this.getProtocol(url);

    if (protocol !== 'http' && protocol !== 'https') {
      return url;
    }


    if (this.isFilePathURI(url)) {
      return url;
    }

    var oldLangCode = this.getLangCode(url);
    var newLangCode = widget.c('Lang').getCode(lang);
    var urlPattern = getCurrentOptions().urlPattern;

    var urlFormatter = widget.c('UrlFormatter').createFromUrl(url);

    return urlFormatter.getConvertedLangUrl(oldLangCode, newLangCode, urlPattern)
  }

  /**
   * Get url for specific language
   * @param {string} lang
   * @param {Element} node
   * @returns {string|null}
   */
  this.langUrl = function(lang, node) {
    var url = node.getAttribute('href');

    var currentOptions = getCurrentOptions();
    if (!currentOptions.urlPattern) {
      return null;
    }

    var protocol = this.getProtocol(url);
    if (protocol !== 'http' && protocol !== 'https') {
      return null;
    }

    if (url && node.host && (node.host.toLowerCase() === location.host.toLowerCase() || currentOptions.urlPattern === 'subdomain')) {
      if (url === '' || url.match(/^[#?]/)) {
        return null;
      }

      url = node.protocol + '//' + node.host + node.pathname + node.search + node.hash;
      if (node.host.toLowerCase() !== location.host.toLowerCase()) {
        // case when urlPattern is subdomain and url absolute
        if (this.getLangCode(url) !== widget.c('Lang').defaultCode()) {
          url = url.replace(new RegExp('://' + widget.c('Lang').getLangIdentifier(this.getLangCode(url)) + '\\.', 'i'), '://');
          node.href = url;
          // we need to check if the hosts actually match again because if the host never contained a language
          var parser = document.createElement('a');
          parser.href = location.href.replace(new RegExp('://' + widget.c('Lang').getLangIdentifier(this.getLangCode(location.href)) + '\\.', 'i'), '://');
          if (node.host.toLowerCase() !== parser.host) {
            return null;
          }
        }
        else {
          return null;
        }
      }
      return this.getUrl(lang, url);
    }
    return null;
  };

  this.changeUrl = function(langCode) {
    if (this.isLiveEditor())
      return;
    var newLocation = this.getUrl(langCode);
    // If a browser doesn't support history.replaceState, the location will be changed
    // ALSO, if the host(subdomain) changes, the location wil also be changed
    try {
      if (widget.c('Data').getOptions().force_reload)
        throw('dummy exception');
      else {
        var newState = window.history.state || {};
        newState['wovn'] = langCode;
        window.history.replaceState(newState, null, newLocation);
      }
    }
    catch (e) {
      location.href = newLocation;
    }
  }

  this.isLiveEditor = function () {
    return /wovn\.editing/i.test(location.hash)
  }

  this.isIframeLiveEditor = function () {
    return /wovn\.iframeEditing/i.test(location.hash)
  }

  this.getEncodedLocation = function (customLocation) {
    return encodeURIComponent(getCurrentLocation(customLocation));
  };

  this.removeHash = function(url) {
    var index = url.indexOf('#');
    return index === -1 ? url : url.substr(0, index);
  };

  /**
   * Gets the current location of the browser without the backend-inserted lang code
   *
   * @return {string} The unicode-safe location of this browser without the lang code
   */
  function getCurrentLocation (currentLocation) {
    // not all browsers handle unicode characters in the path the same, so we have this long mess to handle it
    // TODO: decodeURIcomponent doesnt handle the case where location has char like this: &submit=%8E%9F%82%D6%90i    %82%DE (characters encoded in shift_jis)
    // adding unescape before it makes the error go away but doesnt fix the pb and creates pb for utf8 encode params
    if (!currentLocation)
      currentLocation = location;
    if (typeof(currentLocation) !== 'string')
      currentLocation = currentLocation.protocol + '//' + currentLocation.host + currentLocation.pathname + currentLocation.search;

    if (widget.tag.getAttribute('backend')) {
      var currentLang = widget.tag.getAttribute('currentLang');
      var currentLangIdentifier = widget.c('Lang').getLangIdentifier(currentLang);
      switch (widget.tag.getAttribute('urlPattern')) {
        case 'query':
          currentLocation = currentLocation.replace(new RegExp('(\\?|&)wovn=' + currentLangIdentifier + '(&|$)'), '$1').replace(/(\?|&)$/, '');
          break;
        case 'subdomain':
          currentLocation = currentLocation.replace(new RegExp('//' + currentLangIdentifier + '.', 'i'), '//');
          break;
        case 'path':
          currentLocation = currentLocation.replace(new RegExp('(//[^/]+)/' + currentLangIdentifier + '(/|$)'), '$1/');
      }
    }
    return currentLocation;
  }

  this.apiHostBase = "//ee.wovn.io/";
  this.getApiHost = function () {
    var host = this.apiHostBase;
    return host.replace(/^.*\/\//, '//');
  }

  this.getLocation = function (url) {
    var newLocation = document.createElement('a');
    newLocation.href = url;

    // IE dont load the attributes "protocol" and "host" in case the source URL
    // is just a pathname, that is, "/example" and not "http://domain.com/example".
    newLocation.href = newLocation.href;

    // IE 7 and 6 won't load "protocol" and "host" even with the above workaround,
    // so we take the protocol/host from window.location and place them manually
    if (newLocation.host === "") {
      var newProtocolAndHost = window.location.protocol + "//" + window.location.host;
      if (url.charAt(1) === "/") {
        newLocation.href = newProtocolAndHost + url;
      } else {
        // the regex gets everything up to the last "/"
        // /path/takesEverythingUpToAndIncludingTheLastForwardSlash/thisIsIgnored
        // "/" is inserted before because IE takes it of from pathname
        var currentFolder = ("/"+newLocation.pathname).match(/.*\//)[0];
        newLocation.href = newProtocolAndHost + currentFolder + url;
      }
    }

    return newLocation;
  }

  this.getNormalizedHost = function (location) {
    var host = location.host;

    if (location.protocol === 'http:' && /:80$/.test(host)) {
      host = host.replace(/:80$/, '')
    } else if (location.protocol === 'https:' && /:443$/.test(host)) {
      host = host.replace(/:443$/, '')
    }

    return host;
  }

  /**
   * Say true if url is third-party's link
   */
  this.shouldIgnoreLink = function (url) {
    // get url's location and host
    var urlFormatter = widget.c('UrlFormatter').createFromUrl(url);
    var urlHost = urlFormatter.extractHost();

    // get current location and host
    var curLocationFormatter = widget.c('UrlFormatter').createFromUrl("/");
    var currentHost = curLocationFormatter.extractHost();

    var host_aliases = widget.c('Data').createNormalizedHostAliases();
    host_aliases.push(currentHost);

    return host_aliases.indexOf(urlHost) == -1;
  }
};

if (typeof(components) === 'undefined') var components = {};
components['UrlFormatter'] = function (widget) {
  var locationCache = {};

  function getLocation(url) {
    var langCode = widget.c('Url').getLangCode(url);

    if (!locationCache[url]) {
      locationCache[url] = {};
    }
    if (!locationCache[url][langCode]) {
      locationCache[url][langCode] = widget.c('Url').getLocation(url);
    }

    return locationCache[url][langCode];
  }

  this.createFromUrl = function(url) {
    var location = getLocation(url);
    var host = widget.c('Url').getNormalizedHost(location);

    var startsWithProtocol = /^https?:\/\//.test(url)
    // Sadly, IE removes first "/"
    var pathname = (location.pathname.charAt(0) !== "/" ? "/" : "") + location.pathname;

    // Url#pathname always starts with '/' even if url ends with domain (http://example.com)
    if (startsWithProtocol && /^https?:\/\/.[^/]+$/.test(url)) {
      pathname = '';
    }
    var formatter = new UrlFormatter(location.protocol, host, pathname, location.search, location.hash)

    if (!startsWithProtocol) {
      if (!/^\//.test(url)) {
        var fullUrl = formatter.getOriginalUrl()
        formatter.setBaseIgnorePath(fullUrl.substr(0, fullUrl.indexOf(url)))
      } else {
        formatter.setToShowUrlFromPath();
      }
    }

    return formatter;
  }

  this.create = function(protocol, host, pathname, search, hash) {
    return new UrlFormatter(protocol, host, pathname, search, hash)
  }

  /**
   * Same property name with Spec
   *
   * @see https://html.spec.whatwg.org/multipage/browsers.html#the-location-interface
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Location
   *
   * @param protocol
   * @param host
   * @param pathname
   * @param search
   * @param hash
   * @constructor
   */
  function UrlFormatter(protocol, host, pathname, search, hash) {
    var that = this;
    this.protocol = protocol;
    this.host = host;
    this.pathname = pathname;
    this.search = search;
    this.hash = hash;
    this.fromPath = false;
    this.baseIgnorePath = null;

    this.setShowFullUrl = function () {
      this.fromPath = false;
      this.baseIgnorePath = null;
    }

    this.setToShowUrlFromPath = function () {
      this.fromPath = true;
    }

    this.setBaseIgnorePath = function (path) {
      this.baseIgnorePath = path;
    }

    this.getOriginalUrl = function () {
      return createUrl(that.protocol, that.host, that.pathname, that.search, that.hash);
    }

    this.getNormalizedPageUrl = function (isBackend, urlPattern) {
      var normalizedUrl = that.getOriginalUrl();
      if (isBackend) {
        var langIdentifier = widget.c('Lang').getBackendLangIdentifier();
        switch (urlPattern) {
          case 'query':
            var newSearch = that.search.replace(new RegExp('(\\?|&)wovn=' + langIdentifier + '(&|$)'), '$1').replace(/(\?|&)$/, '');
            normalizedUrl = createUrl(that.protocol, that.host, that.pathname, newSearch, that.hash)
            break;
          case 'subdomain':
            normalizedUrl = normalizedUrl.replace(new RegExp('//' + langIdentifier + '\\.', 'i'), '//');
            break;
          case 'path':
            var sitePrefix = widget.c('Config').getSitePrefixPath();
            if (sitePrefix) {
              var normalizedPath = that.pathname.replace(new RegExp('^/(' + sitePrefix + ')/' + langIdentifier + '(/|$)', 'i'), '/$1$2');
              normalizedUrl = createUrl(that.protocol, that.host, normalizedPath, that.search, that.hash)
            } else {
              var normalizedPath = that.pathname.replace(new RegExp('^(/)?' + langIdentifier + '(/|$)', 'i'), '$2');
              normalizedUrl = createUrl(that.protocol, that.host, normalizedPath, that.search, that.hash)
            }
        }
      }

      return normalizedUrl;
    }

    this.getConvertedLangUrl = function (fromLangCode, toLangCode, urlPattern) {
      var currentUrl = that.getOriginalUrl();
      var newUrl;
      var fromLangIdentifier = widget.c('Lang').getLangIdentifier(fromLangCode);
      var toLangIdentifier = widget.c('Lang').getLangIdentifier(toLangCode);

      switch (urlPattern) {
        case 'query':
          if (toLangCode === widget.c('Lang').defaultCode()) {
            newUrl = currentUrl.replace(/([\?&])wovn=[^#&]*&?/, '$1');
            // url doesn't contain a wovn query param
          }
          else if (!currentUrl.match(/[\?&]wovn=[^&#]*/)) {
            // url has a query string
            if (currentUrl.match(/\?/))
              newUrl = currentUrl.replace(/\?/, '?wovn=' + toLangIdentifier + '&');
            else
              newUrl = currentUrl.replace(/(#|$)/, '?wovn=' + toLangIdentifier + '$1');
          }
          else {
            newUrl = currentUrl.replace(/([\?&])wovn=[^&#]*/, '$1wovn=' + toLangIdentifier);
          }
          // remove trailing ? and &
          newUrl = newUrl.replace(/&$/, '');
          newUrl = newUrl.replace(/\?$/, '');
          break;
        case 'subdomain':
          if (toLangCode === widget.c('Lang').defaultCode())
            newUrl = currentUrl.replace(new RegExp('://' + fromLangIdentifier.toLowerCase() + '\\.', 'i'), '://');
          else if (fromLangCode === widget.c('Lang').defaultCode())
            newUrl = currentUrl.replace(new RegExp('://', 'i'), '://' + toLangIdentifier.toLowerCase() + '.');
          else
            newUrl = currentUrl.replace(new RegExp('://' + fromLangIdentifier.toLowerCase() + '\\.', 'i'), '://' + toLangIdentifier.toLowerCase() + '.');
          break;
        case 'path':
          var newPathname = removeLangFromPathname(urlPattern, that.pathname, fromLangCode);
          newPathname = addLangToPathname(urlPattern, newPathname, toLangCode);
          newUrl = createUrl(that.protocol, that.host, newPathname, that.search, that.hash);
          break;
        default:
          newUrl = currentUrl;
      }
      return newUrl;
    }

    function removeLangFromPathname (urlPattern, pathname, currentLang) {
      if (urlPattern !== 'path') return pathname;

      var langIdentifier = widget.c('Lang').getLangIdentifier(currentLang);
      var sitePrefix = widget.c('Config').getSitePrefixPath();
      if (sitePrefix) {
        return pathname.replace(new RegExp('^(/' + sitePrefix + ')/' + langIdentifier + '(/|$)'), '$1$2');
      } else {
        return pathname.replace(new RegExp('^/' + langIdentifier + '(/|$)'), '$1');
      }
    }

    function addLangToPathname (urlPattern, pathname, lang) {
      if (urlPattern !== 'path') return pathname;
      if (lang === widget.c('Lang').defaultCode()) return pathname;

      var langIdentifier = widget.c('Lang').getLangIdentifier(lang);
      var sitePrefix = widget.c('Config').getSitePrefixPath();
      if (sitePrefix) {
        return pathname.replace(new RegExp('^(/' + sitePrefix + ')(/|$)'), '$1/' + langIdentifier + '$2');
      } else {
        return '/' + langIdentifier + pathname;
      }
    }

    function createUrl (protocol, host, pathname, search, hash) {
      var url = protocol + '//' + host + pathname + search + hash;
      if (that.baseIgnorePath) {
        if (widget.c('Utils').stringStartsWith(url, that.baseIgnorePath, 0)) {
          url = url.replace(that.baseIgnorePath, '')
        } else {
          url = pathname + search + hash;
        }
      } else if (that.fromPath) {
        url = pathname + search + hash;
      }

      return url;
    }

    this.extractHost = function () {
      return that.host;
    }
  }
}

if (typeof(components) === 'undefined') var components = {};
components['ValueStore'] = function (widget) {
  var that = this;
  var langs = widget.c('Data').getPublishedLangs();
  var defaultLang = widget.c('Lang').defaultCode();

  var widgetTranslationData = widget.c('Data').getTranslationData();
  var translationData = widget.c('TranslationData').loadFromStore();
  translationData.update(widgetTranslationData);
  translationData.storeToStorage();

  var textIndex = {};
  var imgIndex = {};
  var htmlTextIndex = {};
  textIndex[defaultLang] = translationData.textVals;
  imgIndex[defaultLang] = translationData.calcImgValsForIndex();
  htmlTextIndex[defaultLang] = translationData.htmlTextVals;

  //cannot add function to Data because of cache.
  var propertyIndex = widget.c('Data').get()['prop_vals'] || {};
  var propertyIndexTags = [];

  var translatedLangs = [defaultLang];
  var imgSrcPrefix = 'http://st.wovn.io/ImageValue/' + widget.c('Data').getPageId() + '/';
  var corruptedVals = [];

  var newDetectedValueSet = {};

  var wovnCommentPrefix = 'wovn-src:';
  var wovnActualLangPrefix = ',wovn-actual-lang:';
  var originalBackgroundAttributeName = 'data-wovn-original-background';

  this.srcsetOriginalValueStore = {};

  /**
   * Property for propertyIndexTags
   * @returns {Array}
   */
  this.propertyIndexTags = function() {
    return propertyIndexTags;
  };

  this.imgSrcPrefix = function() {
    return imgSrcPrefix;
  };

  /**
   * Provides a source text from a given node.
   *
   * @param {Node|Element}    node    The node to convert into a string.
   * @param {Boolean} useInsideWovnIgnore  True if results includes inside wovn-ignore
   * @param {Boolean} surround True if the string must contain the tags of the
   *                          given node, false otherwise.
   *
   * @returns {String} The string representation of the node's data.
   */
  this._nodeToSrc = function(node, useInsideWovnIgnore, surround) {
    var src = ""
    var tagName = node.nodeName.toLowerCase()

    if (tagName == "#text") {
      src = widget.c('Utils').normalizeText(node.data.replace('<', '&lt;').replace('>', '&gt;'), true)
      return src
    }

    if (tagName == 'br' || tagName == 'img') {
      src = "<" + tagName + ">";
      return src
    }

    var content = ""
    var ignoresNode = isIgnoreNode(node)
    var visitsInsideNode = useInsideWovnIgnore || ignoresNode === false
    if (visitsInsideNode) {
      var cs = node.childNodes
      for(var i = 0; i < cs.length; i++) {
        content += widget.c('Utils').normalizeText(that._nodeToSrc(cs[i], useInsideWovnIgnore, true), true)
      }
    }

    if (surround) {
      if (ignoresNode) {
        src = "<" + tagName + " wovn-ignore>" + content + "</" + tagName + ">"
      } else {
        src = "<" + tagName + ">" + content + "</" + tagName + ">"
      }
    } else {
      src = content
    }
    return widget.c('Utils').normalizeText(src, true)
  };

  function isIgnoreNode(node) {
    return node.hasAttribute && node.hasAttribute('wovn-ignore');
  }

  function fixDefaultIndex() {
    fixDefaultLangIndex(imgIndex);
    fixDefaultLangIndex(textIndex);
    fixDefaultLangIndex(htmlTextIndex);
  }

  function fixDefaultLangIndex(index) {
    var defaultIndex = index[defaultLang];
    for (var src in defaultIndex) {
      var entry = defaultIndex[src];
      var xpath = '';
      for (var lang in entry) {
        xpath = entry[lang][0].xpath;
        break;
      }
      if (!entry[defaultLang]) entry[defaultLang] = [{data: src, xpath: xpath}];
    }
  }

  /**
   * Fix propertyIndexTags
   */
  function fixPropertyIndexTags() {
    var tagHash = {};
    for(var i = 0; i < langs.length; i++) {
      var lang = langs[i];
      if (propertyIndex[lang]) {
        var keys = widget.c('Utils').keys(propertyIndex[lang]);
        for(var j = 0; j < keys.length; j++) {
          tagHash[keys[j]] = true;
        }
      }
    }
    propertyIndexTags = widget.c('Utils').keys(tagHash);
  }

  /**
   * Return image linked to original image
   * @param {string} imagePath
   * @param {string} language
   * @returns {string|null}
   */
  this.getDstImage = function(imagePath, language) {
    if (!imagePath) return null;

    var imageData = getImageFromIndex(imagePath, imgIndex[defaultLang]);
    if (imageData && imageData[language]) {
      return imageData[language][0].data;
    }
  };

  /**
   * Return image data
   * @param path {String}
   * @param index {Object}
   * @returns {Object}
   */
  function getImageFromIndex(path, index) {
    if (index.hasOwnProperty(path)) {
      return index[path];
    }
  }

  /**
   * Add propertyIndexTags
   * @param {string} lang
   * @param {string} tagName
   */
  this.addPropertyIndexTag = function(lang, tagName) {
    propertyIndex[lang] = propertyIndex[lang] || [];
    if (!propertyIndex[lang][tagName]) {
      propertyIndex[lang][tagName] = [];
      fixPropertyIndexTags();
    }
  };

  initialize();

  function initialize () {
    fixDefaultIndex();
    fixPropertyIndexTags();

    cleanNewLines();
  }

  this.getTextIndex = function () {
    return textIndex;
  }

  this.getImgIndex = function () {
    return imgIndex;
  }

  this.getHtmlTextIndex = function () {
    return htmlTextIndex;
  }

  /**
   * Searches within the textIndex and htmlTextIndex and normalize any values.
   *
   * @method cleanNewLines
   * @return Does not return a value
   */
  function cleanNewLines () {
    for (var defaultLanguage in textIndex) {
      cleanNewLinesForIndexAndLang(textIndex, defaultLanguage)
    }
    for (var defaultLanguage in htmlTextIndex) {
      cleanNewLinesForIndexAndLang(htmlTextIndex, defaultLanguage)
    }
  }

  function cleanNewLinesForIndexAndLang(index, lang) {
    for (var textNode in index[lang]) {
      if (!index[lang].hasOwnProperty(textNode)) continue;

      var normalizedText = textNode;
      if (index === htmlTextIndex) {
        var dummyElm = document.createElement('P')
        dummyElm.innerHTML = normalizedText;
        normalizedText = that._nodeToSrc(dummyElm, false, false);
      } else {
        normalizedText = widget.c('Utils').normalizeText(textNode);
      }

      if (normalizedText !== textNode) {
        var cleanedNodeValue = index[lang][textNode];
        for (var language in cleanedNodeValue){
          if (!cleanedNodeValue.hasOwnProperty(language)) continue;

          for (var version in cleanedNodeValue[language]){
            if (!cleanedNodeValue[language].hasOwnProperty(version)) continue;
          }
        }

        // create new keys and delete the original
        index[lang][normalizedText] = cleanedNodeValue;
        delete index[lang][textNode];
      }
    }
  }

  this.corruptedVals = corruptedVals;

  this.isCorrupted =  function (val) {
    return isCorrupted(val);
  };

  function isCorrupted (val) {
    if (typeof(val) !== 'object') {
      corruptedVals.push(val);
      return true;
    }
    if (!val.hasOwnProperty('src') || !val.hasOwnProperty('dst') || !val.hasOwnProperty('language')) {
      corruptedVals.push(val);
      return true;
    }
    if (val.src === val.dst) {
      corruptedVals.push(val);
      return true;
    }
    return false;
  }

  function add (nVals) {
    nVals = nVals || [];
    for (var i = 0; i < nVals.length; i++) {
      if (isCorrupted(nVals[i])) {
        continue;
      }
      var index;
      var srcData;
      var data;
      if (/img(\[[^\]]*\])?$/.test(nVals[i].xpath) || nVals[i].src_img_path || /\[@background-image\]$/.test(nVals[i].xpath)) {
        index = imgIndex[defaultLang];
        srcData = nVals[i].src || nVals[i].src_img_path;
        data = nVals[i].dst || nVals[i].img_path;
        if (data !== srcData) data = imgSrcPrefix + data;
      }
      else {
        if (nVals[i].complex === true) {
          index = htmlTextIndex[defaultLang];
        } else {
          index = textIndex[defaultLang];
        }
        srcData = widget.c('Utils').trimString(nVals[i].hasOwnProperty('src') ? nVals[i].src : nVals[i].src_body);
        // replace empty string with the zero-width character. If we don't,
        // the text node disappears on replace.
        data = widget.c('Utils').trimString(nVals[i].hasOwnProperty('dst') ? nVals[i].dst : nVals[i].body) || '\u200b';
      }
      var lang = nVals[i].language;
      widget.c('Utils').pushUnique(translatedLangs, lang);
      if (!index.hasOwnProperty(srcData)) {
        index[srcData] = {}
        index[srcData][defaultLang] = [];
      }
      // dom iterator doesn't support [1]
      index[srcData][defaultLang].push({xpath: (nVals[i].xpath || '').replace(/\[1\]/g, ''), data: srcData});
      if (lang) {
        if (!index[srcData].hasOwnProperty(lang)) index[srcData][lang] = [];
        index[srcData][lang].push({xpath: (nVals[i].xpath || '').replace(/\[1\]/g, ''), data: data});
      }
    }

    // clean new lines if they're mutated
    if (widget.c('Agent').mutatesTextNodeData()) cleanNewLines();
  }
  this.addValues = add;

  function buildIndex (lang) {
    build(textIndex, lang);
    build(htmlTextIndex, lang);
    build(imgIndex, lang);
  }

  /**
   * Build specified index if not build
   *
   * @param {Dictionary} index - Index for build
   * @param {String} lang - lang for build
   * @return Does not return a value
   */
  function build (index, lang) {
    var mergeEntries = function(from, to) {
      for (var i = 0; i < from.length; ++i) {
        if (widget.c('Utils').findIndex(to, from[i], function(entry1, entry2) {return entry1.data === entry2.data && entry1.xpath === entry2.xpath})) {
          to.push(from[i]);
        }
      }
    }
    if (index[lang]) return;
    index[lang] = {};
    for (var defLangSrc in index[defaultLang]){
      if(index[defaultLang].hasOwnProperty(defLangSrc)) {
        var transObj = index[defaultLang][defLangSrc];
        if (transObj[lang]) {
          for (var i = 0; i < transObj[lang].length; i++) {
            var data = transObj[lang][i].data;
            var langTransObj = index[lang][data];
            if (!langTransObj) {
              langTransObj = {};
              index[lang][data] = langTransObj;
            }
            for (var l in transObj) if (transObj.hasOwnProperty(l)) {
              if (!l || !transObj[l]) continue;
              if (!langTransObj[l]) langTransObj[l] = [];
              mergeEntries(transObj[l], langTransObj[l]);
            }
          }
        }
      }
    }
    if(index === textIndex || index === htmlTextIndex) {
      cleanNewLinesForIndexAndLang(index, lang);
    }
  }

  /**
   * Add non-translated value if not added
   * @param value {String}
   */
  this.noteMissedValue = function(value) {
    if (!newDetectedValueSet.hasOwnProperty(value)) {
      newDetectedValueSet[value] = false;
    }
  }

  /**
   * Get and merge non-translated value to textIndex/imgIndex from server
   */
  this.loadNewDetectedValue = function() {
    var valueCountThreshold = 100;

    var values = [];
    for(var value in newDetectedValueSet) {
      if (!newDetectedValueSet.hasOwnProperty(value)) continue;
      if (newDetectedValueSet[value]) continue;
      newDetectedValueSet[value] = true;
      values.push(value);

      if (values.length >= valueCountThreshold) {
        break;
      }
    }

    if (values.length === 0) return;

    var callback = function(d) {
      widget.c('ValueStore').mergeValues(d['text_vals'], d['img_vals'])
    }
    widget.loadTranslation(values, callback, function() {})
  }

  /**
   * Merge new values to textIndex/imgIndex
   * @param textValues {Array<Object>}
   * @param imageValues {Array<Object>}
   */
  this.mergeValues = function(textValues, imageValues) {
    var translationData = widget.c('TranslationData').loadFromStore();
    var newTranslationData = widget.c('TranslationData').create(new Date().getTime(), textValues, imageValues, {})
    translationData.update(newTranslationData);
    translationData.storeToStorage();

    var addedLangs = [];

    var imgVals = newTranslationData.calcImgValsForIndex()
    var zippedObject = [[textValues, textIndex], [imgVals, imgIndex]];
    for (var i = 0; i < zippedObject.length; i++) {
      var values = zippedObject[i][0];
      var index = zippedObject[i][1];
      for (var src in values) {
        if(!values.hasOwnProperty(src)) continue;
        var translation = values[src];

        index[defaultLang][src] = translation;
        var translationLangs = Object.keys(translation);
        for (var j = 0; j < translationLangs.length; j++) {
          widget.c('Utils').pushUnique(addedLangs, translationLangs[j])
        }
      }
    }
    fixDefaultIndex();

    for(var i = 0; i < addedLangs.length; i++) {
      buildIndex(addedLangs[i]);
    }
  }

  // score is calculated by number of nodes that are equal
  function matchScore (a, b) {
    var result = 0;
    var x = a.length - 1;
    var y = b.length - 1;
    while (x >= 0 && y >= 0) {
      if (a[x] !== b[y])
        return result;
      if (a[x] === '/') result++;
      x--;
      y--;
    }
    return result;
  }

  function bestMatch (options, path) {
    if (!options || options.length === 0)
      return null;
    if (options.length === 1)
      return options[0];
    var bestMatch = options[0];
    var bestScore = matchScore(path, options[0].xpath);
    var score = 0;
    for (var i = 1; i < options.length; i++) {
      score = matchScore(path, options[i].xpath);
      if (score > bestScore) {
        bestMatch = options[i];
        bestScore = score;
      }
    }
    return bestMatch;
  }

  /**
   * Save the original data of the node to wovnTranslation and the index.
   * @param {Object} value - an entry of the index ({data: "text", path: "xpath"})
   * @param {NodeContainer} nodeContainer - a NodeContainer that holds the value to translate
   * @return {Object} value
   */
  function saveNodeData(value, nodeContainer) {
    var nodeData = nodeContainer.data || widget.c('ValueStore').getData(nodeContainer);
    if (value && widget.c('Utils').normalizeText(value.data) === widget.c('Utils').normalizeText(nodeData)) {
      value.data = nodeData;
    }
    return value;
  }

  this.srcExists = function (node, langCode) {
    if (!textIndex[langCode])
      buildIndex(langCode);
    var nodeContainer = widget.c('NodeContainer').create(node)
    var data = this.getData(nodeContainer);
    if (data === '') return true;
    var index = getIndex(nodeContainer, langCode);
    return index.hasOwnProperty(data);
  };

  /**
   * Apply property setting from prop_vals
   * @param {Node} node
   * @param {String} newLangCode
   * @param {boolean} forceRevert
   */
  this.applyPropertySetting = function(node, newLangCode, forceRevert) {
    if (forceRevert) {
      revertProperty(node);
    }

    var property = that.getProperty(widget.c('NodeContainer').create(node), newLangCode);
    if (!property) return;

    replaceProperty(property['dst'], node, null);
  };

  /**
   * Get Property setting for specific node
   * @param {NodeContainer} nodeContainer
   * @param {String} newLangCode
   * @returns {Object} property setting
   */
  this.getProperty = function(nodeContainer, newLangCode) {
    if(!(propertyIndex[newLangCode] && propertyIndex[newLangCode][nodeContainer.nodeName])) return null;

    var betterProperties = [];
    for(var i = 0; i < propertyIndex[newLangCode][nodeContainer.nodeName].length; i++) {
      var property = propertyIndex[newLangCode][nodeContainer.nodeName][i];

      if (hasApplyPossibility(property, nodeContainer.node)) {
        betterProperties.push(property);
      }
    }

    var bestProperty = betMatchProperties(betterProperties, nodeContainer.node);
    return bestProperty;
  };

  /**
   * Whether property have any possibility of applying to node
   * @param {Object} property
   * @param {Node} node
   * @returns {boolean}
   */
  function hasApplyPossibility(property, node) {
    for(var srcPropertyName in property['src_property']) {
      if (!property['src_property'].hasOwnProperty(srcPropertyName)) continue;

      if (srcPropertyName === 'childTextContent') {
        var expectedSrc = property['src_property'][srcPropertyName];

        var childTextContent = that.getSrcChildTextContent(node);
        return expectedSrc === childTextContent;
      } else {
        if (window.getComputedStyle(node)[srcPropertyName] !== property['src_property'][srcPropertyName]) {
          return false;
        }
      }
    }

    return true;
  }

  /**
   * Get ndoe-children's data
   * @param {Node} node
   * @returns {string}
   */
  this.getSrcChildTextContent = function(node) {
    var childTextContent = "";
    var children = getChildNodes(node);
    for(var i = 0; i < children.length; i++) {
      var childNodeContainer = widget.c('NodeContainer').create(children[i]);
      if (childNodeContainer.nodeName !== '#text') continue;

      var childSrc = widget.c('ValueStore').getDefaultValue(childNodeContainer, '');
      if (!childSrc || !childSrc.data) continue;

      childTextContent += widget.c('Utils').normalizeText(childSrc.data);
    }
    return childTextContent;
  };

  /**
   * Select best property settings from candidates
   * @param properties
   * @param node
   * @returns {Object}
   */
  function betMatchProperties(properties, node) {
    var maxEstimationPoint = -1;
    var estimatedProperty = null;

    for(var i = 0; i < properties.length; i++) {
      var property = properties[i];
      var selectors = property['dst']['selectors'];
      var estimationPoint = getEstimationPoint(selectors, node);

      if (estimationPoint > 0 && maxEstimationPoint <= estimationPoint) {
        estimatedProperty = property;
        maxEstimationPoint = estimationPoint;
      }
    }

    if (estimatedProperty) {
      return estimatedProperty;
    }
    return null;
  }

  /**
   * Get Property's point for comparing suitable property setting
   * @param {Array.Object.<string, string>}selectors
   * @param {Node} node
   * @returns {number}
   */
  function getEstimationPoint(selectors, node) {
    var currentNode = node;
    var estimationPoint = 0;

    for(var selectorIndex = 0; selectorIndex < selectors.length; selectorIndex++) {
      currentNode = getParentElement(currentNode);
      var selector = selectors[selectorIndex];

      if (currentNode.nodeName.toUpperCase() !== selector['tag_name'].toUpperCase()) {
        return -1;
      }
      var siblings = currentNode.parentNode.children;

      var estimatedPosition = selector['position'] || 0;
      var siblingPosition = 0;
      for(var siblingIndex = 0; siblingIndex < siblings.length; siblingIndex++) {
        var sibling = siblings[siblingIndex];
        if (sibling.nodeName.toUpperCase() == selector['tag_name'].toUpperCase()) {
          if (siblingPosition === estimatedPosition) {
            if (currentNode !== sibling) {
              return -1;
            }
            break;
          }
          siblingPosition++;
        }
      }

      estimationPoint++;
      if (currentNode.getAttribute('id') == selector['element_id']) {
        estimationPoint += 10;
      }
      if (selector['classes'] && currentNode.className) {
        var classes = selector['classes'];
        var nodeClass = widget.c('Utils').to_set(currentNode.className.split(/\s+/));

        for (var classIndex = 0; classIndex < classes.length; classIndex++) {
          if (nodeClass[classes[classIndex]]) {
            estimationPoint += 10 / classes.length;
          }
        }
      }
    }
    return estimationPoint;
  }

  /**
   * Replace Node's property
   * @param {Object} dstProperty
   * @param {Element} node
   * @param {Object} originalProperty
   */
  function replaceProperty(dstProperty, node, originalProperty) {
    revertProperty(node);
    var styleKeys = widget.c('Utils').keys(dstProperty['style']);
    var originalProperty = originalProperty || {style: {}};
    for(var i = 0; i < styleKeys.length; i++) {
      var key = styleKeys[i];
      if(originalProperty.style.hasOwnProperty(key) == false) {
        originalProperty.style[key] = node.style[key];
      }
      node.style[key] = dstProperty['style'][key];

      var rightCssStyleName = key.replace(/([A-Z])/, "-$1").toLowerCase();
      var regex = new RegExp('((' + rightCssStyleName + ': [^;]+?)( !important)?);', 'g');
      node.style.cssText = node.style.cssText.replace(regex, "$1 !important;")
    }

    saveOriginalProperties(originalProperty, node);
  }

  /**
   * Set property to node
   * @param {Object} dstProperty
   * @param {Element} node
   */
  this.setProperty = function(dstProperty, node) {
    var originalProperty = that.getOriginalProperties(node);
    replaceProperty(dstProperty, node, originalProperty);
  };

  /**
   * Revert Property
   * @param {Element} node
   */
  function revertProperty(node) {
    var originalProperty = that.getOriginalProperties(node);
    //supports only style, now
    if (originalProperty && originalProperty['style']) {
      var originalStyle = originalProperty['style'];
      var originalKeys = widget.c('Utils').keys(originalStyle);
      for(var i = 0; i < originalKeys.length; i++) {
        var key = originalKeys[i];
        node.style[key] = originalStyle[key];
      }
    }
  }

  /**
   * Save original property to data attribute
   * @param {Object} properties
   * @param {Element} node
   */
  function saveOriginalProperties(properties, node) {
    node.setAttribute(getOriginalPropertyName(), JSON.stringify(properties));
  }

  /**
   * Get saved property from data attribute
   * @param {Element} node
   * @returns {Object}
   */
  this.getOriginalProperties = function(node) {
    if (node.getAttribute) {
      var propertiesString = node.getAttribute(getOriginalPropertyName());
      if (propertiesString) {
        return widget.c('Utils').parseJSON(propertiesString);
      }
    }
    return null;
  }

  /**
   * Get data attribute's name for original property
   * @returns {string}
   */
  function getOriginalPropertyName() {
    return 'data-wovn-original-property';
  }

  this.getParentElementOverrideFunc = undefined;

  /**
   * Get Parent (override when LiveEditor)
   * @param {Node} node
   * @returns {Node} parent
   */
  function getParentElement(node) {
    if (that.getParentElementOverrideFunc) {
      return that.getParentElementOverrideFunc(node);
    } else {
      return node.parentNode;
    }
  }

  this.getChildNodesOverrideFunc = undefined;

  /**
   * Get Children (override when LiveEditor)
   * @param {Node} node
   * @returns {NodeList} children
   */
  function getChildNodes(node) {
    if (that.getChildNodesOverrideFunc) {
      return that.getChildNodesOverrideFunc(node);
    } else {
      return node.childNodes;
    }
  }

  /**
   * Get the translated value in destLang given the node and xpath
   *
   * @param {NodeContainer} nodeContainer - The NodeContainer that holds the value to translate
   * @param {String} docPath - The xpath of the node
   * @param {String} destLang - The language code of the language to translate to
   * @returns {Hash} the translated value data and path
   * @example {data: 'text', path: 'html/test/path/text()'}
   */
  this.getByValue = function (nodeContainer, docPath, destLang) {
    var node = nodeContainer.node
    var data = this.getData(nodeContainer);
    var actualLang = node.actualLang || widget.c('Lang').getActualLang();

    // cacheLogic for IE
    if (!widget.c('Agent').canStoreObjectInNode() && /text/i.test(nodeContainer.nodeName)) {
      return getByValueFallback(data, nodeContainer, docPath, destLang);
    }

    // if translation not cached, cache it
    var wovnTranslation = node.wovnTranslation;
    if (!wovnTranslation || typeof wovnTranslation !== 'object') {
      // if default lang and no translation, return nothing because it wasn't translated first
      if (destLang === widget.c('Lang').defaultCode()) {
        return null;
      }
      buildIndex(actualLang);
      var index = getIndex(nodeContainer, actualLang);
      var translationData = getTranslation(nodeContainer, index, data);

      // we're keeping this to test non-text nodes
      try {
        node.wovnTranslation = translationData;
      }
      catch (e) {
        var options = (index[data] && (index[data][destLang] || index[data][defaultLang]));
        if (!options) {
          options = [];
        }
        return saveNodeData(bestMatch(options, docPath), nodeContainer);
      }

      if (translationData == undefined) return null;
    }

    that.validateCache(nodeContainer, docPath, destLang);
    if (!node.wovnTranslation) {
      return null;
    }

    // return cached translation
    return saveNodeData(bestMatch(node.wovnTranslation[destLang] || [], docPath), nodeContainer);
  };

  this.translateTexts = function(fromLang, toLang, texts) {
    build(textIndex, fromLang)
    var index = textIndex[fromLang] || {};

    var translatedTexts = {}
    for (var i = 0; i < texts.length; i++) {
      var text = texts[i];

      if (index[text] && index[text][toLang] && index[text][toLang][0]) {
        translatedTexts[text] = index[text][toLang][0]['data'];
      } else {
        translatedTexts[text] = null;
      }
    }

    return translatedTexts;
  }

  this.getCachedOriginalSrcsetAttribute = function (node) {
    return (this.srcsetOriginalValueStore[node] || {})[node.value];
  }

  this.cacheOriginalSrcsetAttribute = function (node, originalValue) {
    if (!this.srcsetOriginalValueStore.hasOwnProperty(node)) {
      this.srcsetOriginalValueStore[node] = {};
    }

    this.srcsetOriginalValueStore[node][node.value] = originalValue;
  }

  /*
   * Get the source url from srcset's attribute,
   * Example:
   *  srcset="hoge.jpg 1x, fuga.png 2x" => ['hoge.jpg', 'fuga.png']
   */
  function getSrcValuesFromSrcsetAttribute(originalAttribute) {
    var singleSrc = /[^\s,]+\s+[^\s,]+/g;
    var terminator = /\s+[^\s]+$/;
    var urls = originalAttribute.match(singleSrc);
    var urlSrcs = {};
    for (var i in urls) {
      if (!urls.hasOwnProperty(i)) continue;
      var src = urls[i].replace(terminator, '');
      var urlFormatter = widget.c('UrlFormatter').createFromUrl(src);
      urlFormatter.setShowFullUrl();
      var fullUrl = urlFormatter.getOriginalUrl();
      urlSrcs[fullUrl] = src;
    }
    return urlSrcs;
  }
  this.getSrcValuesFromSrcsetAttribute = getSrcValuesFromSrcsetAttribute;

  function getSrcsetAttributeTranslation(originalAttribute, srcValues, index, destLang, docPath) {
    if (!originalAttribute) return;
    var newAttribute = originalAttribute;
    for (var fullUrl in srcValues) {
      if (!srcValues.hasOwnProperty(fullUrl)) continue;
      var srcValue = srcValues[fullUrl];
      if (!index[fullUrl]) {
        continue;
      }
      destValue = bestMatch(index[fullUrl][destLang] || [], docPath);
      if (destValue && destValue.data) {
        newAttribute = newAttribute.replace(srcValue, destValue.data);
      }
    }
    return newAttribute;
  }

  /*
   * @param {DOMNode}: srset attribute node of img tag.
   * @return {Array}: srcs that have been swapped.
   */
  this.replaceSrcsetNode = function (node, docPath, destLang) {
    // if cache exist, use it.
    var originalAttribute = this.getCachedOriginalSrcsetAttribute(node) || node.value;
    buildIndex(defaultLang);
    var index = imgIndex[defaultLang];
    var srcValues = getSrcValuesFromSrcsetAttribute(originalAttribute);
    var newAttributes = getSrcsetAttributeTranslation(originalAttribute, srcValues, index, destLang, docPath);

    if (!newAttributes) {
      return [];
    }

    node.value = newAttributes;
    this.cacheOriginalSrcsetAttribute(node, originalAttribute);

    return srcValues;
  }

  /**
   * Get the translated value in destLang given the node containing HTML text
   * and xpath.
   *
   * @param {Node} node The node that holds the value to translate.
   * @param {String} docPath The xpath of the node.
   * @param {String} destLang The language code of the language to translate to.
   *
   * @returns {String} the translated value.
   */
  this.getByComplexValue = function (node, docPath, destLang) {
    var data = getComplexData(node, false)

    buildIndex(destLang);
    var translationData = getComplexTranslationData(node, widget.c('Lang').getDocLang(), data);

    //TODO bestMatch() and saveNodeData()
    if (translationData && translationData[destLang] && translationData[destLang].length > 0) {
      return translationData[destLang][0]
    }
    return null;
  }

  /**
   * Get the translated value in destLang given the node and xpath with comment node
   *
   * @param {String} data
   * @param {NodeContainer} nodeContainer - The NodeContainer that holds the value to translate
   * @param {String} docPath - The xpath of the node
   * @param {String} destLang - The language code of the language to translate to
   * @returns {String} the translated value
   */
  function getByValueFallback(data, nodeContainer, docPath, destLang) {
    var node = nodeContainer.node
    var actualLang = getActualLangFromComment(nodeContainer) || widget.c('Lang').getActualLang();

    buildIndex(actualLang);
    var index = getIndex(nodeContainer, actualLang);

    var translationData = getTranslationDataFromComment(nodeContainer, index);
    if (!translationData && widget.c('Utils').isEmpty(data)) return;
    if (!translationData && destLang === widget.c('Lang').defaultCode()) return;
    if (!translationData || validateValueNotChanged(data, translationData, nodeContainer, docPath) === false) {
      translationData = getTranslationData(nodeContainer, index, data);
      if (!translationData) return;

      saveTranslationDataAsComment(node, translationData, destLang);
    }

    return saveNodeData(bestMatch(translationData[destLang] || [], docPath), nodeContainer);
  }

  /**
   * Check translation is not changed
   * @param originalData {Hash}
   * @param translationData {Hash}
   * @param nodeContainer {NodeContainer}
   * @param docPath {String}
   * @returns {boolean}
   */
  function validateValueNotChanged(originalData, translationData, nodeContainer, docPath) {
    var lang = widget.c('Lang').getActualLang();
    var val = translationData[lang] && saveNodeData(bestMatch(translationData[lang], docPath), nodeContainer);
    return val && widget.c('Utils').normalizeText(val.data) === widget.c('Utils').normalizeText(originalData);
  }

  /**
   * Return translation data
   * When swap is first time and widget is inserted by backend, try to get original source from comment.
   *
   * @param nodeContainer {NodeContainer}
   * @param index {Object}
   * @param data {String}
   * @returns {Object}
   */
  function getTranslation(nodeContainer, index, data) {
    if (widget.c('DomAuditor').isSwappedMoreThanOnce == false && widget.c('Config').backend()) {
      var translationData = getTranslationDataFromComment(nodeContainer, index);

      if (translationData) {
        return translationData;
      }
    }
    return getTranslationData(nodeContainer, index, data);
  }

  /**
   * Return translation data from specific node and index
   * @param nodeContainer {NodeContainer}
   * @param index {Object}
   * @param data {String}
   * @returns {Object}
   */
  function getTranslationData(nodeContainer, index, data) {
    if (index.hasOwnProperty(data)) {
      return index[data];
    }
    var normalizedText = widget.c('Utils').normalizeText(data);
    var translationData = that.getTranslationDataFromIndex(normalizedText, nodeContainer, index);
    if (translationData) {
      return translationData;
    }

    var defaultIndex = getIndex(nodeContainer, defaultLang);
    translationData = that.getTranslationDataFromIndex(normalizedText, nodeContainer, defaultIndex);
    return translationData ? translationData : undefined;
  }

  /**
   * Get data from index
   * @param normalizedText {String}
   * @param nodeContainer {NodeContainer}
   * @param index {Object}
   * @returns {Object}
   */
  this.getTranslationDataFromIndex = function(normalizedText, nodeContainer, index) {
    if (index.hasOwnProperty(normalizedText)) {
      return index[normalizedText];
    }

    if (isImageNode(nodeContainer)) {
      return getImageFromIndex(normalizedText, index);
    }

    return null
  }

  /**
   * Gets the translation data for a given node containing HTML.
   *
   * @param {Node}    node  The node for which to get the translation data.
   * @param {String}  lang  The language of the translation.
   * @param {String}  data  The current data of the node.
   *
   * @returns {String} The translation for the given node and its data.
   */
  function getComplexTranslationData(node, lang, data) {
    var index = getHTMLIndex(lang);

    if (index.hasOwnProperty(data)) {
      return index[data];
    }
    var normalizedText = widget.c('Utils').normalizeText(data);
    if (index.hasOwnProperty(normalizedText)) {
      return index[normalizedText];
    }

    var defaultIndex = getHTMLIndex(defaultLang);
    var translationData = defaultIndex[normalizedText];
    return translationData ? translationData : undefined;
  }

  /**
   * Save the src of the data to the comment node
   *
   * @param {Node} node - a node
   * @param {Object} data - the translation data of the node
   */
  function saveTranslationDataAsComment(node, data, newLangCode) {
    var currentComment = getTranslationDataCommentNode(node);
    var comment = wovnCommentPrefix + data[defaultLang][0]["data"] + wovnActualLangPrefix + newLangCode;
    if(currentComment) {
      currentComment.data = comment;
    } else {
      var srcComment = document.createComment(comment);
      node = getParentOwningNode(node);
      if (node.parentNode) {
        node.parentNode.insertBefore(srcComment, node);
      }
    }
  }

  function getTranslationDataCommentNode(node) {
    var previousSibling = getParentOwningNode(node).previousSibling;
    if(previousSibling && previousSibling.nodeName === '#comment') {
      var comment = previousSibling.data;
      if (comment.indexOf(wovnCommentPrefix) === 0) {
        return previousSibling;
      }
    }
    return null;
  }

  /**
   * Get the actual language of node's data text
   *
   * @param nodeContainer {NodeContainer}
   * @returns {String} Language code of node's data text, such as: en, ja, etc.
   */
  function getActualLangFromComment(nodeContainer) {
    var node = nodeContainer.node;
    var commentNode = getTranslationDataCommentNode(node);
    if (commentNode) {
      var idx = commentNode.data.indexOf(wovnActualLangPrefix);
      if (idx === -1) {
        return null;
      }

      var actualLang = commentNode.data.substring(idx + wovnActualLangPrefix.length);
      return actualLang;
    }

    return null;
  }

  /**
   * Get translation data from comment
   * sometimes data is saved as comment instead of wovnTranslation
   * @param nodeContainer {NodeContainer}
   * @param index {Object}
   * @returns {Object}
   */
  function getTranslationDataFromComment(nodeContainer, index) {
    var node = nodeContainer.node
    var commentNode = getTranslationDataCommentNode(node);

    if (commentNode) {
      var idxActualLang = commentNode.data.indexOf(wovnActualLangPrefix);
      var defaultLangData = '';

      if (idxActualLang == -1) {
        defaultLangData = commentNode.data.substring(wovnCommentPrefix.length);
      }
      else {
        defaultLangData = commentNode.data.substring(wovnCommentPrefix.length, idxActualLang)
      }
      if (defaultLangData.length) return getTranslationData(nodeContainer, index, defaultLangData);
    }

    return null;
  }

  function getParentOwningNode(node) {
    var parentNode = node.parentElement || node.parentNode;
    if (parentNode) {
      // TITLE's wovn-src is added before <title> tag from backend, because HTML doesn't allow
      // Otherwise add inside <title>
      // @see https://www.w3.org/TR/html401/struct/global.html#h-7.4.2
      if (widget.c('DomAuditor').isSwappedMoreThanOnce && parentNode.nodeName === 'TITLE') {
        return parentNode;
      }
      return node;
    } else {
      return node.ownerElement;
    }
  }

  /**
   * Return default language's value
   * @param nodeContainer {NodeContainer}
   * @param docPath {String}
   * @returns {String}
   */
  this.getDefaultValue = function (nodeContainer, docPath) {
    return this.getByValue(nodeContainer, docPath, defaultLang) || {data: that.getData(nodeContainer, true)};
  };

  /**
   * Gets the original data for a given node containing HTML.
   *
   * @param {Node}    node    The node for which to get the translation data.
   * @param {String}  docPath The xpath of the node.
   *
   * @returns {String} The original data of the given node.
   */
  this.getDefaultComplexValue = function (node, docPath) {
    return this.getByComplexValue(node, docPath, defaultLang) || {data: getComplexData(node, false)}
  }

  /**
   * cache translation data by adding "wovnTranslation" property
   *
   * @param nodeContainer {NodeContainer} to cache
   * @param docPath {String}
   * @param destLang {String}
   */
  this.validateCache = function (nodeContainer, docPath, destLang) {
    var node = nodeContainer.node
    var wovnTranslation = node.wovnTranslation;
    if (!wovnTranslation || typeof(wovnTranslation) !== 'object') {
      return;
    }
    var data = this.getData(nodeContainer);
    var lang = node.actualLang || widget.c('Lang').getActualLang();

    var langValue = wovnTranslation[lang];
    var val = langValue && saveNodeData(bestMatch(langValue, docPath), nodeContainer);
    var normalizedText = widget.c('Utils').normalizeText(data);
    if (val && widget.c('Utils').normalizeText(val.data) === normalizedText) {
      return;
    }

    buildIndex(lang);

    var langIndex = getIndex(nodeContainer, lang);
    var translation = this.getTranslationDataFromIndex(normalizedText, nodeContainer, langIndex);
    if (!translation) {
      var defaultLangIndex = getIndex(nodeContainer, defaultLang);
      translation = this.getTranslationDataFromIndex(normalizedText, nodeContainer, defaultLangIndex);
    }
    node.wovnTranslation = translation
  };

  /**
   * Return Index for specified languages
   * @param nodeContainer {NodeContainer}
   * @param langs {String| Array{String}}
   * @returns {Object}
   */
  function getIndex (nodeContainer, langs) {
    var index;
    if (!langs)
      langs = [defaultLang];
    if (typeof langs === 'string')
      langs = [langs];
    if (nodeContainer.nodeName === 'IMG') {
      while (!index && langs.length > 0) {
        index = imgIndex[langs.shift()];
      }
    }
    else if (nodeContainer.nodeName === 'INPUT') {
      while (!index && langs.length > 0) {
        index = imgIndex[langs.shift()];
      }
    }
    else if (nodeContainer.nodeName === 'META') {
      while (!index && langs.length > 0) {
        index = textIndex[langs.shift()];
      }
    }
    // text nodes, attr nodes
    else {
      while (!index && langs.length > 0) {
        index = textIndex[langs.shift()];
      }
    }

    return index;
  }

  function getHTMLIndex (lang) {
    if (!htmlTextIndex[lang]) buildIndex(lang);

    return htmlTextIndex[lang];
  }

  /**
   * Gets the data from inside a node
   * @param {NodeContainer} nodeContainer
   * @param {Boolean} useDefault
   * @returns {String} data - The data of the node
   * @example
   * // returns "hello"
   * this.getData(<input type="text" value="hello">)
   */
  this.getData = function (nodeContainer, useDefault) {
    var data;
    var node = nodeContainer.node;
    if (isValueNode(nodeContainer.getUpperNodeName() || node.name.toUpperCase())) {
      if (useDefault) {
        data = node.value;
      } else {
        data = widget.c('Utils').normalizeText(node.value);
      }
    } else if (isImageNode(nodeContainer)) {
      // if the src attribute is empty, some browser resolve node.src into page
      // URL, but not node.getAttribute('src')
      if (node.getAttribute) {
        data = node.getAttribute('src') ? node.src : '';
      } else {
        // data from live editor are not real nodes, see https://github.com/WOVNio/equalizer/issues/6751
        data = node.src;
      }
    } else {
      if (widget.c('Node').isLegitimateNode(nodeContainer)) {
        data = nodeContainer.data;
      } else {
        if(widget.c('Node').isFirstTextNode(node)) {
          data = widget.c('Node').wholeText(node);
        } else {
          return '';
        }
      }

      if (useDefault !== true) {
        data = widget.c('Utils').normalizeText(data);
      }
    }
    return data;
  };

  /**
   * Gets the data from inside a node containing HTML text.
   *
   * @param {DomElement}  node        The node from which to extract the data.
   * @param {Boolean}     useInsideWovnIgnore  True if the data includes inside wovn-ignore
   *
   * @returns {String} The data of the node.
   *
   * @example
   * // returns "some<a>link</a>."
   * this.getComplexData(<p>some <a href="#">link</a>.</p>)
   */
  function getComplexData (node, useInsideWovnIgnore) {
    var data = that._nodeToSrc(node, useInsideWovnIgnore, false);
    return data
  }

  /**
   * Gets the original data from inside a node containing HTML text.
   *
   * the data includes values inside wovn-ignore
   * @param {Node} node The node from which to extract the data.
   *
   * @returns {String} The original data of the node.
   *
   * @example
   * // returns "some<a wovn-ignore>link</a>."
   * this.getComplexData(<p>some <a wovn-ignore>link</a>.</p>)
   */
  this.getOriginalComplexData = function(node) {
    return that._nodeToSrc(node, true, false);
  }

  /**
   * Check Node's name is relates node to get node.value
   * @param upperName {String}
   * @returns {boolean} true if value needed node
   */
  function isValueNode(upperName) {
    if (upperName === 'ALT') return true;
    if (upperName === 'VALUE') return true;
    if (upperName === 'PLACEHOLDER') return true;
    if (upperName === 'CONTENT') return true;
    if (upperName === 'LABEL') return true;

    return false
  }

  /**
   * Check Node's name is relates node to image
   * @param nodeContainer {NodeContainer}
   * @returns {boolean} true if image node
   */
  function isImageNode(nodeContainer) {
    if (nodeContainer.nodeName === 'IMG') {
      return true;
    }

    if (nodeContainer.nodeName === 'INPUT' && nodeContainer.node.src) {
      return true
    }
  }

  /**
   * Replaces the data of a node
   * @param {NodeContainer} nodeContainer
   * @param {String} data - the data to replace in the node
   */
  this.replaceData = function (nodeContainer, data, newLangCode) {
    if (!data) return;
    var node = nodeContainer.node
    var nodeName = nodeContainer.nodeName;
    switch (true) {
      case /(alt|value|placeholder|content|label)/i.test(nodeName || node.name):
        replaceAttrib(node, data, newLangCode);
        break;
      case /#text/i.test(nodeName):
        replaceText(nodeContainer, data, newLangCode);
        break;
      case /img/i.test(nodeName) || !!(/input/i.test(nodeName) && node.src):
        replaceImg(node, data, newLangCode);
        break;
    }
  };

  /**
   * Replaces the attribute of a node
   * @param {NodeContainer}  nodeContainer The nodeContainer to be replaced.
   * @param {String} attribute
   */
  this.replaceAttribute = function (nodeContainer, attribute, data, newLangCode) {
    var attributeNode = nodeContainer.node.getAttributeNode(attribute);
    nodeContainer.node.actualLang = newLangCode;
    replaceAttrib(attributeNode, data, newLangCode);
  };

  var complexDataCache = {};

  /**
   * Replaces the data of a node that contains HTML text.
   * Entry point for recursive function
   *
   * @param {NodeContainer}  nodeContainer The nodeContainer to be replaced.
   * @param {String}         data The data to put in the node.
   */
  this.replaceComplexData = function(nodeContainer, data, index) {
    replaceComplexDataRecurse(nodeContainer.node, data, index)

    // To shrink time to implement, replace nodeContainer's data here.
    // If necessary, don't hesitate to pass nodeContainer to replaceComplexDataRecurse.
    nodeContainer.refreshData()
  }

  /**
   * Replaces the data of a node that contains HTML text.
   *
   * @param {Node}   node The node to be replaced.
   * @param {String} data The data to put in the node.
   */
  function replaceComplexDataRecurse(node, data, index) {
    if(node.nodeType !== 1) {
      var nodeContainer = widget.c('NodeContainer').create(node)
      replaceText(nodeContainer, data)
    } else {
      if (isIgnoreNode(node)) return;

      var nodeChildren = node.childNodes;

      if(nodeChildren.length > 0) {
        var nodeCache = index || complexDataCache[data];
        if (!nodeCache) {
          var swappingNode = document.createElement(node.tagName);
          swappingNode.innerHTML = data;
          fixEmptyTextNodes(node, swappingNode);
          nodeCache = createComplexDataCache(swappingNode);
          complexDataCache[data] = nodeCache;
        }

        var realIndex = 0;
        for(var i = 0; i < nodeChildren.length; ++i) {
          var swapData = nodeCache[realIndex];

          replaceComplexDataRecurse(nodeChildren[i], swapData, nodeCache[realIndex]);
          realIndex++;
        }
      }
    }
  }

  /**
   * Referencing node, adds empty text nodes to swappingNodes where they are missing
   * @param node {Object} The reference node
   * @param swappingNode {Object} The node to be swapped with (may contain missing text nodes)
   */
  function fixEmptyTextNodes(node, swappingNode) {
    for (var i = 0; i < node.childNodes.length; i++) {
      if (node.childNodes[i].childNodes.length > 0) {
        fixEmptyTextNodes(node.childNodes[i], swappingNode.childNodes[i]);
      }
      else if (!isTextNode(swappingNode)) {
        if (swappingNode.childNodes.length <= i && isTextNode(node.childNodes[i])) {
          var emptyNode = document.createTextNode('');
          swappingNode.insertBefore(emptyNode, null);
        }
        if (swappingNode.childNodes[i] !== undefined && node.childNodes[i].nodeName !== swappingNode.childNodes[i].nodeName && isTextNode(node.childNodes[i])) {
          var emptyNode = document.createTextNode('');
          swappingNode.insertBefore(emptyNode, swappingNode.childNodes[i]);
        }
      }
    }
  }

  /**
   * Checks if the current node is a text node
   * @param node {Object}
   * @returns {boolean}
   */
  function isTextNode(node) {
    return node.nodeType === 3;
  }

  /**
   * Creates the cache of a translation node structure for replaceComplexData().
   *
   * @param {Node} node The translation node to cache.
   *
   * @returns {Array} The cached structure of the node.
   */
  function createComplexDataCache(node) {
    var cache = [];

    if(node.nodeType !== 1) {
      cache.push(node.data);
    } else {
      var nodeChildren = node.childNodes;

      for(var i = 0; i < nodeChildren.length; ++i) {
        var child = nodeChildren[i];
        var subCache = createComplexDataCache(nodeChildren[i])
        if(child.nodeType !== 1) {
          cache = cache.concat(subCache);
        } else {
          cache.push(subCache);
        }
      }
    }

    return cache;
  }

  /**
   * Replaces the text of a text node
   * @param {NodeContainer} nodeContainer
   * @param {String} text - the text to replace in the node
   */
  function replaceText (nodeContainer, text, newLangCode) {
    if (text === undefined) return;
    var originalData = nodeContainer.data;
    var data = originalData.replace(/^(\s*)[\s\S]*?(\s*)$/, '$1' + text.replace(/^\s+/, '').replace(/\s+$/, '').replace(/\$/g, '$$$$') + '$2');
    if (originalData !== data) {
      nodeContainer.replaceData(data, newLangCode)
    }
  }
  this.replaceText = replaceText;

  /*
   * Replaces the src attribute of an image
   * @param {DomElement} node
   * @param {String} data - the url of the new src attribute
   */
  function replaceImg (node, data, newLangCode) {
    // TODO handle case where image has not yet loaded
    // get this info from translate page??
    //if (!node.getAttribute('width') && node.width > 0 && node.height > 0) {
    //  node.setAttribute('width', node.width);
    //  node.setAttribute('height', node.height);
    //}
    if(widget.tag.getAttribute('urlPattern') == 'path') {
      var locationDomainPort = location.hostname;
      if(location.port) {
        locationDomainPort = locationDomainPort + ":" + location.port;
      }

      if (widget.c('Url').getDomainPort(data).toLowerCase() == locationDomainPort) {
        data = widget.c('Url').getUrl(widget.c('Lang').defaultCode(), data);
      }
    }

    node.actualLang = newLangCode;
    replaceAttrib(node.getAttributeNode('src'), data, newLangCode);
  }

  /**
   * Revert Css Image
   * @param {Element} node
   */
  this.revertImage = function(node) {
    if (node.style['backgroundImage'] === 'none') return;

    var originalImage = getOriginalBackgroundImage(node);
    if (!originalImage && originalImage !== '') return;

    node.style['backgroundImage'] = originalImage;
  };

  /**
   * Get original background image
   * @param node {Element}
   * @returns {string}
   */
  function getOriginalBackgroundImage(node) {
    return node.getAttribute(originalBackgroundAttributeName);
  }

  /**
   * Set original background image
   * @param node {Element}
   * @returns {string}
   */
  function setOriginalBackgroundImage(node) {
    node.setAttribute(originalBackgroundAttributeName, node.style['backgroundImage'] || '');
  }

  /**
   * Replace Css Image
   * @param {Element} node
   * @param {string} dstImage
   */
  this.replaceCssImageData = function(node, dstImage) {
    var originalImage = getOriginalBackgroundImage(node);
    if (!originalImage && originalImage !== '') {
      setOriginalBackgroundImage(node);
    }

    if (dstImage) {
      node.style['backgroundImage'] = 'url(' + dstImage + ')';
    } else {
      node.style['backgroundImage'] = '';
    }
  };

  /*
   * Replaces the value of an attribute node
   * @param {DomElement} node - is an attribute node (like alt="")
   * @param {String} data - the new value of the attribute node
   */
  function replaceAttrib (node, data, newLangCode) {
    if (node && node.value !== data) {
      node.value = data;
      node.actualLang = newLangCode;
    }
  }

  this.getTranslatedLangs = function () {
    return translatedLangs;
  };

  this.empty = function () {
    for (var val in textIndex[defaultLang]){if(textIndex[defaultLang].hasOwnProperty(val)) {
      return false;
    }}
    for (var val in htmlTextIndex[defaultLang]){if(htmlTextIndex[defaultLang].hasOwnProperty(val)) {
      return false;
    }}
    for (var val in imgIndex[defaultLang]){if(imgIndex[defaultLang].hasOwnProperty(val)) {
      return false;
    }}
    return true;
  };
};

if (typeof(components) === 'undefined') var components = {};
components['DomAuditor'] = function (widget) {
  // TODO: we might want to initialize this so that we can add custom values
  NonRecursiveTextContainers = ['div', 'p', 'pre', 'blockquote', 'figcaption', 'address', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'dt', 'dd', 'th', 'td'];
  InlineTextContainers = ['span', 'a', 'em', 'strong', 'small', 'tt', 's', 'cite', 'q', 'dfn', 'abbr', 'time', 'code', 'var', 'samp', 'sub', 'sup', 'i', 'b', 'kdd', 'mark', 'u', 'rb', 'rt', 'rtc', 'rp', 'bdi', 'bdo', 'wbr', 'nobr'];
  AllowedWithinTextContainers = ['br', 'img', 'ruby', 'ul', 'ol'];

  var that = this;
  var srcs;
  var newSrcs;
  var reportedCssImages;
  var newCssImages;
  var hasNewMissedSrc;
  var auditCount;
    var reportTime = widget.c('Url').hasFlag('instantReport') ? 1000 : 5000;

  var reportTimer;
  var reportTimerResetCount;
  var reportCount;
  var forceReporting = false;
  var currentLang = undefined;

  this.isSwappedMoreThanOnce = false;

  if (!widget.c('Url').isIframeLiveEditor()) {
    widget.c('AuditTrigger').auditor = audit;
  }

  /**
   * Get current language
   * while swapping value, previous language is returned
   * @returns {String}
   */
  this.getInternalCurrentLang = function() {
    return currentLang
  }

  this.setReportTime = function(time) {
    reportTime = time;
  }

  function reset() {
    srcs = {};
    newSrcs = {};
    reportedCssImages = {};
    newCssImages = {};
    hasNewMissedSrc = false;
    auditCount = 0;
    clearTimeout(reportTimer);
    reportTimer = undefined;
    reportTimerResetCount = 0;
    reportCount = 0;
  }

  reset();

  /**
   * Check value needs to report
   * @param src {String}
   * @returns {boolean}
   */
  function isAddableSrc(src) {
    // FILTER OUT NON-TRANSLATEABLE VALUES
    // 翻訳できないvalueを除く
    // prevent sources with bad encoding to break the report
    try {
      encodeURIComponent(widget.c('Utils').toJSON(src));
    }
    catch(err) {
      return false;
    }

    var trimmedSrc = widget.c('Utils').trimString(src);
    var rxEncodedURIComponent = /^(%([a-f]|[0-9]){2})+$/i;

    return trimmedSrc !== '' && !rxEncodedURIComponent.test(trimmedSrc);
  }
  this.isAddableSrc = isAddableSrc;

  function createDataObject(src, xpath, complex, isThirdParty, isUnifiedValue) {
    return {
      src           : src,
      xpath         : xpath,
      complex       : complex,
      unified       : Boolean(isUnifiedValue),
      is_third_party: isThirdParty,
      exists        : true
    };
  }

  function addSrc(src, xpath, complex, isThirdParty, isUnifiedValue) {
    if (widget.c('Lang').getActualLang() === widget.c('Lang').defaultCode()) {
      var srcObject = createDataObject(src, xpath, complex, isThirdParty, isUnifiedValue);

      function needsUpdate(srcObject) {
        return /meta/.test(srcObject.xpath) || srcObject.is_third_party;
      }

      if (!isUnifiedValueChild(srcObject)) {
        if (!srcs.hasOwnProperty(src)) {
          if (!newSrcs.hasOwnProperty(src) || needsUpdate(newSrcs[src])) {
            newSrcs[src] = srcObject;
          }
        }
        if (!srcs.hasOwnProperty(src) || needsUpdate(srcs[src])) {
          srcs[src] = srcObject;
        }
      }
    }
  }
  this.addSrc = addSrc;

  function isUnifiedValueChild (value) {
    if (!value.complex && widget.c('Data').useFragmentedValue() && value.xpath.match(/text\(\)$/)) {
      for (key in srcs) {
        if (srcs.hasOwnProperty(key)) {
          var existingValue = srcs[key];
          if (existingValue.complex && widget.c('Utils').stringStartsWith(value.xpath, existingValue.xpath)) {
            return true;
          }
        }
      }
    }

    return false;
  }

  /**
   * Swaps through nodes on the page and translates content
   * @param {String} newLangCode
   * @param {Object} options - for test purposes can determine the start point of the swapping
   * @param {boolean} swapsProperty - true if swapProperty (default is true)
   */
  this.swapVals = function (newLangCode, options, swapsProperty) {
    if (widget.c('Data').useUnifiedValue()) {
      widget.c('PerformanceMonitor').mark('swap_start');
      widget.c('UnifiedValue').swapUnifiedValue(
          document.head.parentNode,
          currentLang,
          newLangCode);
      widget.c('PerformanceMonitor').mark('swap_end');
      currentLang = newLangCode;
      this.isSwappedMoreThanOnce = true;
      if (widget.c('Data').dynamicLoading()) {
        widget.c('ValueStore').loadNewDetectedValue();
      }
      return
    }

    if (!options) options = {};

    var target = ['#text', 'img', 'meta', 'a', 'area', 'form', 'input', 'textarea', 'option'];
    var attributes = null;
    if (widget.c('Data').useAriaLabel()) {
      attributes = attributes ? attributes : {};
      attributes['aria-label'] = function(node, xpath) {
        var nodeContainer = widget.c('NodeContainer').create(node)
        nodeContainer.data = node.getAttribute('aria-label');
        var newVal = widget.c('ValueStore').getByValue(nodeContainer, xpath, newLangCode);
        if (newVal) {
          widget.c('ValueStore').replaceAttribute(nodeContainer, 'aria-label', newVal.data, newLangCode);
        }
      };
    }
    var propertyIndexTags = widget.c('ValueStore').propertyIndexTags();
    for(var i = 0; i < propertyIndexTags.length; i++) {
      target.push(propertyIndexTags[i]);
    }
    // for fragmented values feature, dom iterator must call block on more text
    // container targets
    if (widget.c('Data').useFragmentedValue()) {
      target = target.concat(NonRecursiveTextContainers);
      target = target.concat(InlineTextContainers);
    }

    widget.c('PerformanceMonitor').mark('swap_start');
    // default arguments
    if (swapsProperty !== false) {
      swapsProperty = true
    }
    var everyBlockFn = swapsProperty ? everyBlock: function () {}

    widget.c('DomIterator').go({
          target: target,
          attributes: attributes,
          filter: this.createFilterCallback(),
          head: options.head
        }, block, everyBlockFn);
    currentLang = newLangCode;
    this.isSwappedMoreThanOnce = true;
    widget.c('PerformanceMonitor').mark('swap_end');
    if (widget.c('Data').dynamicLoading()) {
      widget.c('ValueStore').loadNewDetectedValue();
    }

    function isSrcsetNode(_, xpath) {
      return xpath && xpath.match(/\[@srcset]$/)
    }

    /**
     * Callback function when visit target Element
     *
     * @param {Node}    node
     * @param {String}  xpath
     * @param {Boolean} isThirdParty
     *
     * @return {Boolean} True to prevent from visiting children of node, false
     *                   otherwise.
     */
    function block (node, xpath, isThirdParty) {
      //Because IE is too slow to resolve DOM's attribute, need to reduce access as possible
      if (isSrcsetNode(node, xpath)) {
        swapSrcset(node, xpath, isThirdParty);
      }

      var isTranslatedComplexNode = false;
      // handle forms (for backend)
      var tagName = node.tagName;
      if (tagName === 'FORM') {
        if (widget.c('Config').urlPattern('query') && (!node.getAttribute('method') || node.getAttribute('method').toUpperCase() === 'GET')) {
          var children = node.children;
          // start from the end because the hidden field is inserted at the end
          for (var i = children.length - 1; i >= 0; i--) {
            if (children[i].tagName === 'INPUT' && children[i].getAttribute('name') === 'wovn' && children[i].getAttribute('type') === 'hidden') {
              children[i].setAttribute('value', newLangCode);
              return false;
            }
          }

          // input doesn't exist, so create it
          var hiddenField = document.createElement('input');
          hiddenField.setAttribute('type', 'hidden');
          hiddenField.setAttribute('name', 'wovn');
          hiddenField.setAttribute('value', newLangCode);
          node.appendChild(hiddenField);
        }
        else if (widget.c('Config').backend()) {
          var oldAction = !node.getAttribute('action') || node.getAttribute('action').length === 0 ? location.href : node.getAttribute('action');
          if (!widget.c('Url').shouldIgnoreLink(oldAction)) {
            var newAction = widget.c('Url').getUrl(newLangCode, oldAction);
            node.setAttribute('action', newAction);
          }
        }
        return false;
      }
      // INSERT META NAME/PROPERTY VALUE HERE
      // meta elements without a name/property value are filtered out
      if (tagName === 'META') {
        xpath += node.getAttribute('name') ? "[@name='" + node.getAttribute('name') + "']" : "[@property='" + node.getAttribute('property') + "']";
        var contentNode = node.getAttributeNode('content')
        if (contentNode && contentNode.value !== '') {
          block(contentNode, xpath);
        }
        return false;
      }

      if (tagName === 'OPTION') {
        if (node.hasAttribute('label')) {
          xpath += "[@label]"
          var contentNode = node.getAttributeNode('label')
          if (contentNode && contentNode.value !== '') {
            block(contentNode, xpath);
          }
        }
        return false;
      }

      if (tagName === 'IMG' && node.hasAttribute('alt') && node.getAttribute('alt') !== '') {
        block(node.getAttributeNode('alt'), xpath + '[@alt]');
      }

      if ((tagName === 'IMG' || (tagName === 'INPUT' && node.getAttribute('type') === 'image')) && isThirdParty) {
        return true
      }

      if (tagName === 'INPUT') {
        if (node.hasAttribute('value') && node.getAttribute('value') !== '' && node.hasAttribute('type') && node.getAttribute('type') !== "text" && node.getAttribute('type') !== "search" && node.getAttribute('type') !== "password" && node.getAttribute('type') !== "number") {
          block(node.getAttributeNode('value'), xpath + '[@value]');
        }
        if (node.hasAttribute('alt') && node.getAttribute('alt') !== '') {
          block(node.getAttributeNode('alt'), xpath + '[@alt]');
        }
      }

      if (tagName === 'INPUT' || tagName === 'TEXTAREA') {
        if (node.hasAttribute('placeholder') && node.getAttribute('placeholder') !== '') {
          block(node.getAttributeNode('placeholder'), xpath + '[@placeholder]');
        }
      }

      if (tagName === 'IMG') {
        if (node.hasAttribute('srcset') && node.getAttribute('srcset') !== '') {
          block(node.getAttributeNode('srcset'), xpath + '[@srcset]');
        }
      }

      var nodeContainer = widget.c('NodeContainer').create(node)
      if (isHrefTag(tagName)) {
        var langUrl = widget.c('Url').langUrl(newLangCode, node);
        if (langUrl && !widget.c('Url').isLiveEditor()) {
          node.setAttribute('href', langUrl);
        }
      }

      // unified value detection
      if (
        widget.c('Data').useFragmentedValue() &&
        isTextValue(node, xpath) &&
        !isValidTextNode(node, xpath)
      ) {
        var defaultVal = widget.c('ValueStore').getDefaultComplexValue(node, xpath);
        if (defaultVal && defaultVal.data) {
          var originalSrc = widget.c('ValueStore').getOriginalComplexData(node)
          var newVal = widget.c('ValueStore').getByComplexValue(node, xpath, newLangCode);
          if (newVal) {
            isTranslatedComplexNode = true;

            widget.c('ValueStore').replaceComplexData(nodeContainer, newVal.data);
          }
          addSrc(originalSrc, xpath, true, isThirdParty);
        }
      } else if (isReplaceValueTarget(nodeContainer, tagName)) {
        if (isSVGNonSwappableTextNode(xpath)) {
          return false;
        }
        if (tagName === 'INPUT' && nodeContainer.node.src) {
          xpath += '[@image]';
        }
        var src = widget.c('ValueStore').getDefaultValue(nodeContainer, xpath);

        if (!src) return false;
        var srcData = src.data;
        if (!srcData) return false;
        if (!isAddableSrc(srcData)) return false;
        var newVal = widget.c('ValueStore').getByValue(nodeContainer, xpath, newLangCode);

        if (!newVal) {
          newVal = src;
          noteMissedValueIfNeeded(srcData, tagName, newLangCode);
          if (!srcs.hasOwnProperty(srcData)) hasNewMissedSrc = true;
        }
        widget.c('Node').disableIllegitimateNode(nodeContainer);

        widget.c('ValueStore').replaceData(nodeContainer, newVal.data, newLangCode);
        if (widget.c('Node').isLegitimateNode(nodeContainer)) {
          addSrc(src.data, xpath, false, isThirdParty);
        }
      }
      if (tagName === 'INPUT' || tagName === 'TEXTAREA') return false;

      var forceRevert = newLangCode !== currentLang;
      widget.c('ValueStore').applyPropertySetting(node, newLangCode, forceRevert);
      return isTranslatedComplexNode;
    }

    function swapSrcset(node, xpath, isThirdParty) {
      var originalSrcs = widget.c('ValueStore').replaceSrcsetNode(node, xpath, newLangCode)
      var newSrcset = node.value;

      for (var fullUrl in originalSrcs) {
        if (!originalSrcs.hasOwnProperty(fullUrl)) continue;
        var src = originalSrcs[fullUrl];
        var dataObject = createDataObject(fullUrl, xpath, true);

        if (!srcs.hasOwnProperty(dataObject) && newSrcset.indexOf(src) !== -1) {
          hasNewMissingSrcs = true;
        }
        addSrc(fullUrl, xpath, false, isThirdParty);
      }
    }

    function isSVGNonSwappableTextNode(xpath) {
      return /\/svg\/.*text\(\)/.test(xpath) && !/\/text\/text\(\)$/.test(xpath);
    }

    /**
     * Check there is possibility of having href attributes
     * @see http://www.w3schools.com/tags/att_href.asp
     * @param tagName {String}
     * @returns {boolean}
     */
    function isHrefTag(tagName) {
      return tagName === 'A' || tagName === 'AREA'
    }

    /**
     * True if node can replace text or image
     * @param nodeContainer {NodeContainer}
     * @param tagName {String}
     * @returns {boolean}
     */
    function isReplaceValueTarget(nodeContainer, tagName) {
      if (nodeContainer.nodeName === '#text' && widget.c('Utils').trimString(nodeContainer.node.textContent) !== '') {
        return true;
      }

      if (nodeContainer.isValueNode()) {
        return true;
      }

      if (tagName === 'IMG' || tagName === 'META' || tagName === 'FORM' || tagName === 'OPTION') {
        return true;
      }

      if (tagName === 'INPUT' && nodeContainer.node.src) {
        return true;
      }
      return false;
    }

    /**
     * Add non-translated value if needed for user
     * @param value {String}
     * @param tagName {String}
     * @param newLangCode {String}
     */
    function noteMissedValueIfNeeded (value, tagName, newLangCode) {
      // Use DynamicLoading only if translation is needed for user.
      if (newLangCode === widget.c('Lang').defaultCode()) return;

      // Ignore image values to reduce access.
      if (tagName === 'IMG') return;

      widget.c('ValueStore').noteMissedValue(value);
    }

    /**
     * Callback Function called when visit all node
     * @param {Node} node
     * @param {String} xpath
     */
    function everyBlock(node, xpath, isThirdParty) {
      if (widget.c('Utils').canStyleChange(node)) {
        var defaultCssImage = applyCssImage(node);
        if (defaultCssImage) {
          addSrc(defaultCssImage, xpath + '[@background-image]', false, isThirdParty);
        }
      }
    }

    /**
     * Determines if a given HTML node represent a TextValue.
     * @param node [Object] The node to check.
     * @param path [String] The xpath of the current node.
     * @return [Boolean] True if the node represent a TextValue, false otherwise.
     */
    function isTextValue(node, path) {
      if (isValidTextNode(node, path)) return true;
      if (isParentOfSingleTextContainer(node, path)) return false;
      if (isEmptyTextContainer(node, path)) return false;
      if (!isValidTextContainer(node)) return false;
      return true;
    }

    /**
     * Determines if a given HTML node is a text node that can be used as TextValue. Empty text nodes are rejected.
     * @param node [Object] The node to check.
     * @param path [String] The xpath of the current node.
     * @return [Boolean] True if the node is a valid text node, false otherwise.
     */
    function isValidTextNode(node, path) {
      return node.nodeName.toLowerCase() === '#text' && node.nodeValue.replace(/^[`~!@#\$%\^&\*\(\)\-_=\+\[\{\]\}\|;:'",\/\\?]+$/, '') !== ''
    }

    /**
     * Determines if a given HTML node contains only one text container.
     * In that case we want to continue the scraping further down.
     * @param node [Object] The node to check.
     * @return [Boolean] True if the node contains a single text container, false otherwise.
     */
    function isParentOfSingleTextContainer(node, path) {
      var nonEmptyChildrenRes = nonEmptyChildren(node);

      if (nonEmptyChildrenRes.length === 0) return true;
      if (nonEmptyChildrenRes.length === 1 && isValidTextNode(nonEmptyChildrenRes[0], path)) return true;
      if (nonEmptyChildrenRes.length === 1 && isValidTextContainer(nonEmptyChildrenRes[0])) return true;
      return false;
    }

    function isEmptyTextContainer(node, path) {
      return widget.c('Utils').normalizeText(node.innerText || '', true) === '';
    }

    /**
     * Retrieves the non-empty children of a given HTML node.
     * @param node [Object] The node to check.
     * @ return [Array] The non-empty children of the given node.
     */
    function nonEmptyChildren(node) {
      var children = [];
      if (node.childNodes) {
        var values = new Array();
        for(var i = 0; i < node.childNodes.length; i++){
          values.push(node.childNodes[i]);
        }
        children = values.filter(function (n) {
          var result = true;
          if (n.nodeName.toLowerCase() === '#text' && widget.c('Utils').normalizeText(n.nodeValue)) {
            result = n;
          }
          return result;
        });
      }

      return children;
    }

    /**
     * Determines if a given HTML node contains only text.
     * @param node [Object] The node to check.
     * @returns {boolean} True if the node is a valid text container, false otherwise.
     */
    function isValidTextContainer(node) {
      if (isNonRecursiveTextContainer(node) || isInlineTextContainer(node)) {
        if (node.childNodes.length > 0) {
          for (var i = 0; i < node.childNodes.length; ++i) {
            if (!isAcceptedWithinTextContainer(node.childNodes[i])) return false;
          }
        }
        return true
      }
      return false
    }

    /**
     * Tells if a given HTML node belongs to the category of nodes that can
     * represent text value, but cannot contain another node of this category.
     * @param node [Object] The node to check.
     * @returns {boolean} True if the node is a non-recursive container, false otherwise.
     */
    function isNonRecursiveTextContainer(node) {
      return widget.c('Utils').indexOf(NonRecursiveTextContainers, node.nodeName.toLowerCase()) > -1;
    }

    /**
     * Tells if a given HTML node belongs to the category of nodes that can represent text value.
     * @param node [Object] The node to check.
     * @returns {boolean} True if the node is an inline container, false otherwise.
     */
    function isInlineTextContainer(node) {
      return widget.c('Utils').indexOf(InlineTextContainers, node.nodeName.toLowerCase()) > -1;
    }

    /**
     * Tells if a given HTML node is allow to be within a TextValue.
     * @param node [Object] The node to check.
     * @returns {boolean} True if the node can be within a TextValue, false otherwise.
     */
    function isAcceptedWithinTextContainer(node) {
      if (!isNonRecursiveTextContainer(node) && (widget.c('Utils').indexOf(AllowedWithinTextContainers, node.nodeName.toLowerCase()) != -1 || isInlineTextContainer(node))) {
        if (node.childNodes.length > 0) {
          for (var i = 0; i < node.childNodes.length; ++i) {
            if (!isAcceptedWithinTextContainer(node.childNodes[i])) return false;
          }
        }

        return true;
      }

      return node.nodeName.toLowerCase() === '#text'
    }

    /**
     * Swap images defined by css
     * @param {Node} node
     * @returns {String} defalut image's path
     */
    function applyCssImage(node) {
      var defaultImage = null;

      if (newLangCode !== currentLang) {
        widget.c('ValueStore').revertImage(node);
      }
      var imagePath = getUrlFromCssImageNode(node);

      if (newLangCode !== currentLang) {
        if (node.style['backgroundImage'] === '') {
          defaultImage = imagePath;
        }
      }

      var dstImage = widget.c('ValueStore').getDstImage(imagePath, newLangCode);
      if (imagePath && dstImage && imagePath !== dstImage) {
        widget.c('ValueStore').revertImage(node);
        defaultImage = getUrlFromCssImageNode(node);

        widget.c('ValueStore').replaceCssImageData(node, dstImage);
      }

      defaultImage = defaultImage || node.getAttribute('data-wovn-style-image');
      return defaultImage;
    }

    function getUrlFromCssImageNode(node) {
      var backgroundImage = window.getComputedStyle(node).getPropertyValue('background-image');
      return widget.c('Parser').getUrlFromCss(backgroundImage);
    }
  };

  /**
   * Filters out the nodes that should not be visited by swapVals
   * @returns {Function}
   * @example
   * // returns true
   * this.createFilterCallback with node: <a wovn-ignore>
   * // returns false
   * this.createFilterCallback with node: <a href="next.html">
   */
  this.createFilterCallback = function () {
    return function (node, xpath) {
      if (typeof(node.getAttribute) === 'function' && node.getAttribute('wovn-ignore') !== null)
        return true;

      var nodeName = node.nodeName;
      if (isScriptOrStyle(nodeName))
        return true;

      if (filterThirdPartyContent(node, nodeName))
        return true;

      if (filterMetaTags(node, nodeName))
        return true;

      if (filterOptionLabel(node, nodeName))
        return true;

      if (filterInputTags(node, nodeName))
        return true;

      if (filterExtensionContents(node, xpath))  {
        return true;
      }

      return false;

      /**
       * Return true if nodeName is script or style related
       * @param nodeName {String}
       * @returns {boolean}
       */
      function isScriptOrStyle(nodeName) {
        if (nodeName === "SCRIPT") return true
        if (nodeName === "NOSCRIPT") return true
        if (nodeName === "STYLE") return true

        return false
      }
    };
  }

  /**
   * Filters out third party content
   * @param node {Node}
   * @param nodeName {String} equal to node.nodeName, exits to reduce the number of access
   * @returns {boolean}
   */
  function filterThirdPartyContent(node, nodeName) {
    if (filterAds(node, nodeName)) return true;

    return false;
  }

  /**
   * Filters out intercom.io chat content
   * @param node {Node}
   * @param nodeName {String} equal to node.nodeName, exits to reduce the number of access
   * @returns {boolean}
   */
  function filterIntercomIo(node, nodeName) {
    return node.id && (node.id === 'intercom-container' || node.id === 'intercom-frame');
  }

  /**
   * Filters out Adwords
   * @param node {Node}
   * @param nodeName {String} equal to node.nodeName, exits to reduce the number of access
   * @returns {boolean}
   */
  function filterAds(node, nodeName) {
    return nodeName === 'IMG' && /googlesyndication\.com/i.test(node.src);
  }

  /**
   * Filter for Input tags - will filter anything but button or submit types with value or placeholder attributes
   * @param {Node} node
   * @param {String} nodeName
   * @returns {Boolean}
   * @example
   * // returns false
   * filterInputTags('<input type="text" value="Hello">', 'html/body/div/input')
   */
  function filterInputTags (node, nodeName) {
    if (nodeName !== 'INPUT') return false;

    var nodeType = node.getAttribute('type');
    // keep input button, submit with value
    if (/^(button|submit)$/i.test(nodeType) && node.getAttribute('value'))
      return false;
    // keep text, search, password, number with placeholder
    if (/^(email|text|search|password|number)$/i.test(nodeType) && node.getAttribute('placeholder'))
      return false;
    if (/^image$/i.test(nodeType) && node.src)
      return false;

    return true;
  }

  /**
   * Filter for meta tag
   * @param node {Element}
   * @param nodeName {String}
   * @returns {boolean}
   */
  function filterMetaTags (node, nodeName) {
    if (nodeName !== 'META') return false;
    // RegExp.test on null is always false
    return !(/^(description)$/.test(node.getAttribute('name')) || /^(og:description|twitter:description|og:title|twitter:title)$/.test(node.getAttribute('property')));
  }

  /**
   * Filter for option tag
   * @param node {Element}
   * @param nodeName {String}
   * @returns {boolean}
   */
  function filterOptionLabel (node, nodeName) {
    if (nodeName !== 'OPTION') return false;
    return !node.hasAttribute('label') && node.innerText.length <= 0;
  }

  var bodyElement = document.body;

  /**
   * Filter for google's translation information
   * @param node {Node}
   * @param xpath {String}
   * @returns {boolean}
   */
  function filterExtensionContents(node, xpath) {
    return node.id === "goog-gt-tt" // chrome auto translation information
        || filterAfterNode(node, bodyElement); // extension content added after the body
  }

  /**
   * Filter nodes existing after arguments's node
   * @param currentNode {Node}
   * @param beforeNode {Node}
   * @returns {boolean}
   */
  function filterAfterNode(currentNode, beforeNode) {
    var nextNode = beforeNode.nextSibling;

    while(nextNode) {
      if(nextNode === currentNode) return true;

      nextNode = nextNode.nextSibling;
    }

    return false;
  }

  function postSrcs(path, srcs, onEachPost, onComplete) {
    if (srcs.length === 0) {
      if (onComplete) onComplete();
      return;
    }
    var r = new XMLHttpRequest();
    var host = widget.c('Url').getApiHost();
    r.open("POST", host + path, true);
    r.onreadystatechange = function () {
      if (r.readyState != 4 || r.status != 200) return;
      if (onEachPost) onEachPost(r.responseText);
      if (onComplete) onComplete();
    };
    r.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    var postBody = '';

    var srcJson = widget.c('Utils').toJSON(srcs, null, 4);
    postBody += 'url=' + widget.c('Url').getEncodedLocation() + '&no_record_vals=' + encodeURIComponent(srcJson);

    if (reportCount === 1 && widget.c('ValueStore').corruptedVals.length > 0) postBody += '&corruptedVals=' + encodeURIComponent(JSON.stringify(widget.c('ValueStore').corruptedVals, null, 4));
    r.send(postBody);
  }

  function mergeNewSrcs() {
    for (var src in newSrcs) {
      if (newSrcs.hasOwnProperty(src)) {
        if (!srcs.hasOwnProperty(src) || /meta/.test(srcs[src].xpath))
          srcs[src] = newSrcs[src];
      }
    }
    newSrcs = {};
    hasNewMissedSrc = false;
  }

  function reportVals() {
    if (location.hash.match(/wovn.haltReporting/) || location.hash.match(/wovn.editing/) || haltReporting) return;
    ++reportCount;
    mergeNewSrcs();
    var restSrcs = [];
    for (var src in srcs) if (srcs.hasOwnProperty(src)) restSrcs.push(srcs[src]);
    postSrcs("report_values/" + widget.tag.getAttribute('key'), restSrcs);
  }

  function isReportable() {
    return !(widget.c('Config').backend() && widget.c('Lang').getDocLang() !== widget.c('Lang').defaultCode());
  }

  function resetReportTimer() {
    if (!isReportable()) return;
    ++reportTimerResetCount;
    clearTimeout(reportTimer);
    mergeNewSrcs();
    reportTimer = setTimeout(function () {
      reportTimerResetCount = 0;
      reportVals();
    }, reportTime);
  }

  this.reportCount = function () {
    return reportCount;
  };

  this.resetReportCount = function () {
    reportCount = 0;
    clearTimeout(reportTimer);
  };

  function hasNewSrc() {
    for (var src in newSrcs) if (newSrcs.hasOwnProperty(src)) return true;
    return false;
  }

  /**
   * Swap and report
   * @param callback {Function}
   * @param swapsProperty {boolean}
   */
  function audit(callback, swapsProperty) {
    if (location.hash.match(/wovn.debugAudit/))
      console.log("AUDIT");
    auditCount++;

    var lang = widget.c('Lang').getDocLang() || widget.c('Lang').defaultCode();
    widget.c('DomAuditor').swapVals(lang, null, swapsProperty || true);
    if(containsThirdPartyContents()) {
      // remove newly found srcs as they could contain third party contents
      removeNewSrcs();
    }
    if (forceReporting || (widget.c('Data').dynamicValues() && reportCount < 10 && reportTimerResetCount < 10 && (hasNewSrc() && hasNewMissedSrc))) {
      resetReportTimer();
      forceReporting = false;
    }
    if (callback) setTimeout(callback, 0);
  }

  this.audit = audit;

  function containsThirdPartyContents() {
    if (isChromeTranslating()) return true;
    if (isLanguageTranslated()) return true;
    if (isGoogleAnalyticsExtensionWorking()) return true;

    return false;
  }

  function isChromeTranslating() {
    //return document.documentElement.classList.contains("translated-ltr")
    //       || document.documentElement.classList.contains("translated-rtl");
    return document.documentElement.className.match("translated");
  }


  /**
   * Checks if the language in the wovn widget were translated by external service
   * @param langSwitches {Array of DomElement}
   * @returns {boolean} true if translated, false if not
   */
  function isLanguageTranslated(langSwitches) {
    var widgetElement = widget.c('Interface').getWidgetElement();
    var dataTheme = widgetElement && widgetElement.getAttribute('data-theme');
    // do not check for customize widget
    if (dataTheme && dataTheme === 'built-in') return false;
    var langSwitches = langSwitches || widgetElement && widgetElement.querySelectorAll('.wovn-switch');
    if (langSwitches && langSwitches.length > 0) {
      for (var i=0; i<langSwitches.length; i++) {
        langAttribute = langSwitches[i].getAttribute('data-value');
        langObject = langAttribute && widget.c('Lang').get(langAttribute);
        langName = langObject && langObject.name;
        if (langName && langName !== langSwitches[i].innerHTML) {
          return true;
        }
      }
    }
    return false;
  }
  this.isLanguageTranslated = isLanguageTranslated;

  function isGoogleAnalyticsExtensionWorking () {
    var googleAnalyticsExtensionElements = document.getElementsByClassName('view-in-ga-link-logo')

    for (var i = 0; i < googleAnalyticsExtensionElements.length; i++) {
      var element = googleAnalyticsExtensionElements[i];
      if (/chrome-extension:\/\/.+analytics_logo\.png/.test(getComputedStyle(element)['background-image'])) {
        return true;
      }
    }

    return false;
  }

  function removeNewSrcs() {
    for(var src in newSrcs) {
      if(srcs.hasOwnProperty(src)) {
        delete srcs[src]
      }
    }
    newSrcs = {};
    hasNewMissedSrc = false;
  }

  this.stop = function () {
    reset();
    widget.c('AuditTrigger').stop();
  };

  this.destroy = function () {
    that.stop();
  };


  if (!widget.c('Url').isIframeLiveEditor()) {
    var haltReporting = widget.c('Agent').mutatesTextNodeData();

    forceReporting = (widget.c('Lang').missingAutoTranslateLangs() || widget.c('Lang').missingAutoPublishLangs() || (widget.c('ValueStore').corruptedVals.length > 0 && Math.random() < 0.1) || location.hash.match(/wovn.forceReporting/));
  }
};

if (typeof(components) === 'undefined') var components = {};
components['AuditTrigger'] = function(widget) {
  var that = this;
  var timeout;
  var editMode = false;

  this.auditor = function () {};

  this.auditWorker = widget.c('SingleWorker').createSingleWorker();

  widget.c('Utils').onDomReady(function () {
    var touchEnabled = 'ontouchstart' in document;
    var clickNodes = [document.body];
    clickNodes = clickNodes.concat(widget.c('Utils').toArrayFromDomList(document.getElementsByTagName('a')));
    clickNodes = clickNodes.concat(widget.c('Utils').toArrayFromDomList(document.getElementsByTagName('button')));
    clickNodes = clickNodes.concat(widget.c('Utils').toArrayFromDomList(document.getElementsByTagName('input')));
    for (var i = 0; i < clickNodes.length; i++) {
      // add touch listener instead of click if the device is touch enabled
      if (touchEnabled){
        processEvent(clickNodes, i, 'touchend');
      } else {
        processEvent(clickNodes, i, 'click');
      }
    }
  }, true);

  /**
   * At each event trigger, renews the timer of the audit or decorates the page
   * @param {object} clickNodes html nodes on the page being tracked for events
   * @param {number} i the node index
   * @param {string} eventName the event name
   */
  function processEvent(clickNodes, i, eventName) {
    widget.c('Utils').onEvent(clickNodes[i], eventName, function () {
      if (!editMode) {
        renewTimeout();
      }
      else {
        if (widget.c('Url').isLiveEditor()) {
          widget.c('EditorInterface').decoratePage();
        }
      }
    });
  }

  this.start = function() {
    renewTimeout();
  };

  this.editStop = function() {
    editMode = true;
    clearTimeout(timeout);
  };

  this.stop = function() {
    clearTimeout(timeout);
  };

  this.destroy = function() {
    that.stop();
  };

  /**
   * reset Audit's count and execute audit
   * @param maxInterval
   */
  function renewTimeout(maxInterval) {
    if (!maxInterval) maxInterval = 25000;

    var totalAuditCount = 5;
    var currentAuditCount = 0;
    var callAudit = function() {
      // When current language is same as default, almost values are properly swapped (includes new values).
      // so reduce opportunity of swapVals()
      if (widget.c('DomAuditor').getInternalCurrentLang() === widget.c('Lang').defaultCode()) {
        if (currentAuditCount % 2 === 0) {
          return
        }
      }
      // First SwapVals() is slower than later, (maybe because of JIT or DOM's cache?)
      // For faster rendering (e.g. scroll), ignore everyBlock's swap (everyBlock is for swap css' image)
      var swapsProperty = currentAuditCount !== 0;
      that.auditor(null, swapsProperty);
    };

    var bookNext = function() {
      if (currentAuditCount >= totalAuditCount) return;
      currentAuditCount++;
      var interval = maxInterval * Math.pow(currentAuditCount, 2) / Math.pow(totalAuditCount, 2);
      that.auditWorker.setTimeout(callAudit, bookNext, interval);
    }
    that.auditWorker.setTimeout(callAudit, bookNext, 0);
  }
};

if (typeof(components) === 'undefined') var components = {};
components['Interface'] = function(widget) {
  var that = this;
  //var translating = false;

  this.WIDGET_ID = 'wovn-translate-widget';
  this.BUILT_IN_ID = 'wovn-languages';
  var appendedChildren = [];
  var attachedHandlers = [];
  var widgetElement;

  this.addClass = function (ele, targetClass) {
    var trimmedClass = widget.c('Utils').trimString(targetClass);
    var rx = new RegExp('(^| )' + trimmedClass + '( |$)');
    // if class list already contains className
    if (rx.test(ele.className)) return;
    ele.className = ele.className.length == 0 ? targetClass : ele.className + ' ' + targetClass;
  }

  this.removeClass = function (ele, targetClass) {
    var trimmedClass = widget.c('Utils').trimString(targetClass);
    var rx = new RegExp('(^| )' + trimmedClass + '( |$)', 'g');
    var className = ele.className.replace(rx, '').replace(/\s+/g, ' ');
    ele.className = widget.c('Utils').trimString(className);
  }

  function wovnGetElementsByClassName(node, classname) {
    if (typeof document.getElementsByClassName === 'function')
      return node.getElementsByClassName(classname);
    else {
      var a = [];
      var re = new RegExp('(^| )' + classname + '( |$)');
      var els = node.getElementsByTagName("*");
      for (var i = 0, j = els.length; i < j; i++)
        if (re.test(els[i].className) || re.test(els[i].getAttribute('class')))
          a.push(els[i]);
      return a;
    }
  }

  function setInnerHTMLByClass(ancestor, className, value) {
    var targets = wovnGetElementsByClassName(ancestor, className);
    for (var i = 0; i < targets.length; i++)
      targets[i].innerHTML = value;
  }

  function onEvent (target, eventName, handler) {
    widget.c('Utils').onEvent(target, eventName, handler);
    attachedHandlers.push({'target': target, 'eventName': eventName, 'handler': handler});
  }

  this.insertStyles  = function (styles) {
    if (!styles) return;
    if (styles.constructor === Array)
      styles = styles.join('\n');
    var styleElement = document.createElement('style');
    styleElement.type = 'text/css';
    styleElement.className = 'wovn-style';
    try {
      styleElement.innerHTML = styles;
    }
    catch (e) {
      styleElement.styleSheet.cssText = styles;
    }
    document.getElementsByTagName('head')[0].appendChild(styleElement);
    appendedChildren.push(styleElement);
  }

  function disableBrowserTranslation () {
    if (widget.c('Utils').getMetaElement('google', {value: 'notranslate'})) return;
    var chrome = document.createElement('meta');
    chrome.setAttribute('name', 'google');
    chrome.setAttribute('value', 'notranslate');
    document.getElementsByTagName('head')[0].appendChild(chrome);
    appendedChildren.push(chrome);
  }

  function getQueryVal(param, href) {
    var link = !href ? window.location : function () {
      var l = document.createElement('a');
      l.setAttribute('href', href);
      return l;
    }();
    param = encodeURIComponent(param);
    var match = link.search.match(new RegExp(param + '=([^&#?]*)'));
    return (match && match[1]) || '';
  }

  var lastViewportWidth = null;
  var lastViewportHeight = null;
  /**
   * Rescale the widget element
   * @param selector widget element node
   */
  function rescaleWidget (selector) {
    selector = selector || document.getElementById('wovn-translate-widget');
    if (!selector) return;
    var ruler = document.createElement('div');
    ruler.setAttribute('style', 'position:fixed;display:block;visibility:hidden;right:0;left:0;padding:0;font-size:16px;border:0;');
    document.body.appendChild(ruler);
    var viewportWidth = ruler.offsetWidth;
    ruler.setAttribute('style', 'position:fixed;display:block;visibility:hidden;width:1px;top:0;bottom:0;');
    var viewportHeight = ruler.offsetHeight;
    document.body.removeChild(ruler);
    // if the last variables are initialized and
    // both of them haven't changed, return
    if (lastViewportWidth &&
        lastViewportHeight &&
      !(lastViewportWidth !== viewportWidth &&
        lastViewportHeight !== viewportHeight))
      return;
    // formula derived from the following constraints
    // widget should cover 2.5% of the screen area in portrait
    // widget should cover 5% of the screen area in landscape
    // percent covered is actually fontSize*viewportWidth (not actually entire widget)
    // using this fs*width/width*height => fs/height = (.05 and .025 respectively)
    // so we need fs = height*x where x is based on the dimensions of the viewport
    // using Sony XPeria Z1's dimensions, a linear function
    // was derived which yields .025 in portrait and .05 in landscape
    // the resulting function was plugged in for x giving us
    // height*(function with width and height inputs)
    // this was reduced to the following form below
    var fontSize = viewportWidth*.0205714 + viewportHeight*.0134286;
    selector.style.fontSize = fontSize + 'px';
    lastViewportWidth = viewportWidth;
    lastViewportHeight = viewportHeight;
  }

  var scrollTop = 0;
  var widgetTimeout = 0;
  function showWidget () {
    if (document.body.scrollTop < scrollTop) {
      window.clearTimeout(widgetTimeout);
      widgetTimeout = setTimeout(animHideWidget, 3000);
      rescaleWidget();
      animShowWidget();
    }
    scrollTop = document.body.scrollTop;
  }

  /**
   * set animation to hide the widget
   */
  function animHideWidget() {
    var widget = document.getElementById('wovn-translate-widget');
    if (!widget) return;
    // if dropdown is open, wait 3 more seconds before trying to hide
    if (widget.getElementsByTagName('ul')[0].style.display === 'block')
      widgetTimeout = setTimeout(animHideWidget, 3000);
    else
      widget.className = widget.className.replace(/slide-in/, 'slide-out slid-out');
  }

  /**
   * set animation to show the widget
   */
  function animShowWidget() {
    var widget = document.getElementById('wovn-translate-widget');
    if (!widget) return;
    rescaleWidget();
    widget.className = widget.className.replace(/slid-out/, '').replace(/slide-out/, 'slide-in');
  }

  /**
   * Build Widget's Language List
   *
   * @param langs to use
   */
  function buildWidgetLangList (langs) {
    var widgetElem = document.getElementById(that.WIDGET_ID);
    if (!widgetElem) return;
    var widgetList = widgetElem.className.match(/\bwovn-lang-list\b/) ? widgetElem : wovnGetElementsByClassName(widgetElem, 'wovn-lang-list')[0];
    if (!widgetList) return;

    langs = langs || [];

    // c('Url').getLangCode will return the path lang if using backend or wovnDefaultLang otherwise
    var selectedLang = widget.c('Url').getLangCode();
    if (selectedLang != widget.c('Lang').getDocLang()) {
      selectedLang = widget.c('Lang').getDocLang();
    }
    if (widget.c('Utils').findIndex(langs, selectedLang, function (ele, val) { return ele.code === val;}) === -1) {
      selectedLang = widget.c('Lang').defaultCode();
    }
    var listItem, selectedLangName;
    for (var i = 0; i < langs.length; i++) {
      var lang = langs[i];
      listItem = document.createElement('li');
      listItem.setAttribute('class', 'wovn-switch');
      listItem.innerHTML = lang.name;
      listItem.setAttribute('data-value', lang.code);
      if (lang.code == selectedLang) {
        listItem.setAttribute('class', 'wovn-switch selected');
        selectedLangName = lang.name;
      }

      widgetList.appendChild(listItem);
    }

    setInnerHTMLByClass(widgetElem, 'wovn-current-lang', selectedLangName || '');
  }

  function getWovnLangQuery(lang_code) {
    var query = window.location.search;
    // change wovn parameter
    if (query.replace(/\?/, '').length == 0) {
      return 'wovn=' + lang_code;
    }
    else if (query.match(/wovn=/)) {
      return query.replace(/wovn=[^&]*/, 'wovn=' + lang_code);
    }
    else {
      return query + '&wovn=' + lang_code;
    }
  }

  /**
   * Flag of changeLang() is working or not
   * @type {boolean}
   */
  var changingLang = false;

  /**
   * Change Language
   * If argument is string, convert to appropriate element.
   * If 'ed' is argued, LiveEditor starts.
   *
   * @param ele element or language's code
   */
  this.changeLang = function (ele) {
    if (changingLang) {
      setTimeout(function(){that.changeLang(ele);}, 100);
      return;
    }
    changingLang = true;
    var oldLang = widget.c('Lang').defaultCode();
    var isEd = false;
    if (typeof(ele) === 'string') {
      isEd = (ele === 'ed');
      var lis = document.getElementById(that.WIDGET_ID);
      if (lis) {
        lis = wovnGetElementsByClassName(lis, 'wovn-switch');
        var langCode = ele;
        ele = lis[0];
        for (var i = 0; i < lis.length; i++) {
          if (lis[i].getAttribute('data-value') === langCode)
            ele = lis[i];
        }
      }
    }
    if (isEd) {
      var loadedOne = false;
      function kickoffEditor () {
        if (loadedOne)
          widget.c('EditorInterface').start();
        else
          loadedOne = true;
      }
      widget.loadComponents(['Vue', 'EditorInterface'], {'Vue': kickoffEditor, 'EditorInterface': kickoffEditor});
    }
    // if we got the element (it's not a string)
    if (ele.parentElement) {
      var listItems = wovnGetElementsByClassName(ele.parentElement, 'wovn-switch');
      for (var i = 0; i < listItems.length; i ++) {
        if (listItems[i].className.indexOf('selected') != -1)
          oldLang = listItems[i].getAttribute('data-value');
        that.removeClass(listItems[i], 'selected');
      }
      that.addClass(ele, 'selected');
      var currentLangEle = ele.parentElement.parentElement.parentElement;
      setInnerHTMLByClass(currentLangEle, 'wovn-current-lang', ele.textContent || ele.innerText);
      newLang = ele.getAttribute('data-value');
    } else {
      oldLang = widget.c('Lang').getDocLang();
      newLang = ele;
    }
    widget.c('Lang').setDocLang(newLang);
    if (widget.c('ParcelForwarding').banner) {
      widget.c('ParcelForwarding').banner.changeLang();
    }
    changingLang = false;
  };

  function attachLangClickHandlers () {
    var widgetElem = document.getElementById(that.WIDGET_ID);
    if (!widgetElem) return;
    var clickTargets = wovnGetElementsByClassName(widgetElem, 'wovn-switch');
    if (clickTargets.length === 0) clickTargets = widgetElem.getElementsByTagName('a');
    if (clickTargets.length === 0) clickTargets = widgetElem.getElementsByTagName('li');
    if (clickTargets.length === 0) return;

    for (var i = 0; i < clickTargets.length; i++) {
      onEvent(clickTargets[i], 'click', function(ele) {
        return function () {that.changeLang(ele);};
      }(clickTargets[i]), false);
    }
  }

  var widgetOptionShori = (function () {
    var shoris = {};
    shoris.type = function (opts, opt) {
      var type = opts[opt];
      if (type === 'widget' || (type === 'auto' && !document.getElementById(that.BUILT_IN_ID)) || (type !== 'built_in' && type !== 'auto' && type !== 'widget')) {
        buildWidgetLangList(widget.c('Lang').getConvertedLangs());
        attachLangClickHandlers();
        return;
      }
      if (type === 'built_in' && !document.getElementById(that.BUILT_IN_ID)) {
        that.insertStyles('#wovn-translate-widget {display: none !important;}');
        return;
      }
      var dataAttribute = '';
      if (document.getElementById(that.WIDGET_ID)) {
        var oldWidget = document.getElementById(that.WIDGET_ID);
        dataAttribute = oldWidget.getAttribute('data-ready');
        oldWidget.parentNode.removeChild(oldWidget);
      }
      that.WIDGET_ID = that.BUILT_IN_ID;
      var container = document.getElementById(that.WIDGET_ID);
      container.setAttribute('data-ready', dataAttribute);
      container.setAttribute('data-theme', 'built-in');
      // if there is a template
      if (wovnGetElementsByClassName(container, 'wovn-switch-template').length !== 0) {
        var original = wovnGetElementsByClassName(container, 'wovn-switch-template')[0];
        var hasSwitch = original.className.match(/(^| )wovn-switch( |$)/i) || function () {
          for (var i = 0; i < original.children.length; i++) {
            if (original.children[i].className.match(/(^| )wovn-switch( |$)/i))
              return true;
          }
          return false;
        }();
        // if there's no switch class we will put it on the template element
        if (!hasSwitch) that.addClass(original, 'wovn-switch');
        var template = document.createElement('div');
        template.appendChild(original.cloneNode(true));
        var newSwitch;
        var convertedLangs = widget.c('Lang').getConvertedLangs();
        for (var i = 0; i < convertedLangs.length; i++) {
          newSwitch = document.createElement('div');
          newSwitch.innerHTML = template.innerHTML.replace(/wovn-lang-name/g, convertedLangs[i].name);
          wovnGetElementsByClassName(newSwitch, 'wovn-switch')[0].setAttribute('data-value', convertedLangs[i].code);
          original.parentNode.insertBefore(newSwitch.children[0], original);
        }
        original.parentNode.removeChild(original);
      }
      // if there are no switches in the container, we may have to build them
      else if (wovnGetElementsByClassName(container, 'wovn-switch').length === 0) {
        // if there are no anchors (and no switches), we have to build the inner structure
        if (container.getElementsByTagName('a').length === 0) {
          container.innerHTML = '';
          if (container.nodeName.toLowerCase() === 'ul' || container.nodeName.toLowerCase() === 'ol') {
            var list = container;
            that.addClass(list, 'wovn-lang-list');
          }
          else {
            var list = document.createElement('ul');
            list.className = 'wovn-lang-list';
            container.appendChild(list);
          }
          buildWidgetLangList(widget.c('Lang').getConvertedLangs());
        }
        // if there are no switches, but there are anchor tags, make the anchor tags switches
        else {
          var switches = container.getElementsByTagName('a');
          for (var i = 0; i < switches.length; i++)
            switches[i].className = switches[i].className + (switches[i].className.length > 0 ? switches[i].className + ' ' : '') + 'wovn-switch';
        }
      }
      attachLangClickHandlers();
    };
    shoris.position = function (opts, opt) {
      if (!opts[opt] || opts[opt] === 'default') return;
      var widgetElem = document.getElementById(that.WIDGET_ID);
      if (widgetElem) that.addClass(widgetElem, 'position-' + opts[opt].replace(/[ _]/g, '-'));
    };

    /**
      * Hide widget by setting and browser language.
      *
      * @param opts {Object} widget.c('Data').getOptions()
      * @param opt {String} always returns 'auto_hide_widget'
      */
    shoris.auto_hide_widget = function (opts, opt) {
      if (!opts[opt] || (typeof opts[opt] === 'string' && !opts[opt].match(/true/i))) return;
      var browserLang = widget.c('Lang').getBrowserLang();
      var rx = new RegExp('^' + widget.c('Data').getLang(), 'i');
      if (widget.c('Data').getLang() === browserLang || rx.test(browserLang)) {
        var widgetElem = document.getElementById(that.WIDGET_ID);
        if (widgetElem) widgetElem.parentNode.removeChild(widgetElem);

        var builtIn = document.getElementById(that.BUILT_IN_ID);
        if (builtIn) builtIn.parentNode.removeChild(builtIn);
      }
    };

    /**
     * Hide WOVN.io logo.
     * @param opts {Object} widget.c('Data').getOptions()
     * @param opt {String} always returns 'hide_logo'
     */
    shoris.hide_logo = function (opts, opt) {
      if (!opts[opt]) return;
      var widgetElem = document.getElementById(that.WIDGET_ID);
      if (widgetElem) {
        that.addClass(widgetElem, 'hide-logo');
      }
    };

    /**
     * Show translated by machine image
     * @param opts {Object} widget.c('Data').getOptions()
     */
    shoris.show_tbm = function (opts) {
      if (opts["show_tbm"] !== true) return;
      var widgetElem = document.getElementById(that.WIDGET_ID);
      if (widgetElem) {
        that.addClass(widgetElem, 'show-tbm');
      }
    };

    return function (options, opt) {
      if (typeof shoris[opt] === 'object') {
        if (arguments.length === 3 && typeof arguments[2] === 'string' && typeof shoris[opt][arguments[2]] === 'function')
          return shoris[opt][arguments[2]](options, opt);
      }
      else if (typeof shoris[opt] === 'function')
        return shoris[opt](options, opt);
    };
  })();

  function applyWidgetOptions(options) {
    if (options) var opts = options;
    else if (widget.c('Data').getOptions()) var opts = widget.c('Data').getOptions();
    else return;
    var widgetOptionStyles = (widget.c('Data').get().widgetOptions && widget.c('Data').get().widgetOptions.css) || {};
    var styles = [];
    for (var opt in opts){if(opts.hasOwnProperty(opt)) {
      if (widgetOptionStyles.hasOwnProperty(opt)) {
        if (typeof opts[opt] === 'boolean') {
          if (opts[opt]) styles.push(widgetOptionStyles[opt]);
        }
        else {
          styles.push(widgetOptionStyles[opt]);
        }
      }
      var shoriResult = widgetOptionShori(opts, opt);
      // if shori result is an array
      if (typeof shoriResult === 'object' && shoriResult.constructor === Array) styles = styles.concat(shoriResult);
    }}
    that.insertStyles(styles);

    // user must have parcel_forwarding feature and viewer must be outside Japan
    if (!!opts.parcel_forwarding && widget.c('Data').getCountryCode() !== 'JP') {
      var loadedOne = false;
      function kickoffParcelForwarding () {
        if (loadedOne)
          widget.c('ParcelForwarding').start();
        else
          loadedOne = true;
      }
      widget.loadComponents(['Vue', 'ParcelForwarding'], {'Vue': kickoffParcelForwarding, 'ParcelForwarding': kickoffParcelForwarding});
    }
    // 404 unpublish feature
    if (opts.not_found_unpublish && widget.c('Data').getPublishedLangs().length > 0) {
      widget.c('PageChecker').notifyWovnIfNotFound();
    }
  }

  this.build = function() {
    if (!document || !document.body) setTimeout(function () {that.body(options)}, 100);
    var oldWidget = document.getElementById('wovn-translate-widget');
    if (oldWidget) oldWidget.parentNode.removeChild(oldWidget);

    while (true) {
      var oldStyles = document.getElementsByClassName('wovn-style')
      if (oldStyles.length == 0) {
        break;
      }
      // oldStyles' elements is removed when node is removed
      oldStyles[0].parentNode.removeChild(oldStyles[0])
    }
    var styles = "#wovn-translate-widget[wovn] {\n    display: none;\n    position: fixed;\n    z-index: 9999999999;\n    top: auto;\n    right: 0;\n    bottom: 25px;\n    left: auto;\n    margin: 0;\n    padding: 0 0 0 9px;\n    font-size: 12px;\n    color: #6c7984;\n    background: #f6f8fa;\n    border: solid 1px #dee5ec;\n    border-right: none;\n    border-radius: 3px 0 0 3px;\n    -webkit-box-shadow: 0 2px 0 0 rgba(0, 0, 0, .03);\n    -moz-box-shadow: 0 2px 0 0 rgba(0, 0, 0, .03);\n    box-shadow: 0 2px 0 0 rgba(0, 0, 0, .03);\n}\n\n#wovn-translate-widget[wovn].mobile {\n    top: auto;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    padding: 0;\n    font-size: 16px;\n    border-right: none;\n    border-left: none;\n    border-bottom: none;\n    border-radius: 0;\n    -webkit-box-shadow: none;\n    -moz-box-shadow: none;\n    box-shadow: none;\n    height: 48px;\n}\n\n#wovn-translate-widget[wovn].wovn-element-hide {\n    display: none;\n}\n\n#wovn-translate-widget[wovn] #wovn-collapse-btn {\n    position: absolute;\n    width: 9px;\n    top: 0;\n    right: auto;\n    bottom: 0;\n    left: 0;\n    margin: 0;\n    padding: 0;\n    cursor: pointer;\n}\n\n#wovn-translate-widget[wovn].mobile #wovn-collapse-btn {\n    right: auto;\n    left: 0;\n    width: 12%;\n}\n#wovn-translate-widget[wovn] #wovn-collapse-btn:hover {\n    background-position: right 22px;\n}\n#wovn-translate-widget[wovn] #wovn-content {\n    position: relative;\n    display: block;\n    top: auto;\n    right: auto;\n    bottom: auto;\n    left: auto;\n    margin: 0;\n    padding: .65em 10px .65em 0;\n}\n#wovn-translate-widget[wovn].mobile #wovn-content {\n    text-align: left;\n    padding: 8px;\n    height: 48px;\n    margin: 0;\n}\n#wovn-translate-widget[wovn] h6 {\n    box-sizing: initial;\n    position: relative;\n    margin: 0 85px 0 0;\n    display: block;\n    padding: 0 16px 0 6px;\n    width: 102px;\n    font-weight: normal;\n    font-family: Verdana, sans-serif;\n    font-size: 1em;\n    border: 1px solid #dee5ec;\n    border-radius: 3px;\n    line-height: 1.8em !important;\n    font-weight: 400;\n    color: #6c7984;\n    overflow: visible;\n    background: white;\n    cursor: pointer;\n    outline: none;\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -khtml-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n    min-width: 70px;\n}\n#wovn-translate-widget[wovn] h6:before,\n#wovn-translate-widget[wovn] h6:after {\n  content: none;\n}\n#wovn-translate-widget[wovn] h6 > span.wovn-current-lang {\n    font-size: 12px !important;\n    position: static;\n    margin: 0;\n    display: inline;\n    padding: 0;\n    text-transform: none;\n    font-family: Verdana, sans-serif;\n    font-size: 1em;\n    font-style: normal;\n    border: none;\n    line-height: 1.8em;\n    font-weight: 400;\n    color: #545f66;\n    opacity: 0.7;\n    white-space: nowrap;\n    background: transparent;\n    outline: none;\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -khtml-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n\n#wovn-translate-widget[wovn].mobile h6 > span.wovn-current-lang {\n    line-height: 32px;\n}\n\n#wovn-translate-widget[wovn].mobile h6 {\n    box-sizing: initial;\n    display: inline-block;\n    min-width: 7.5em;\n    margin: 0 103px 0 0;\n    height: 30px;\n}\n\n#wovn-translate-widget[wovn] #wovn-content:hover h6 {\n    box-sizing: initial;\n    border: 1px solid #bec8d2;\n}\n\n#wovn-translate-widget[wovn] #wovn-content:active h6 {\n    box-sizing: initial;\n    background-color: #EEF1F3;\n}\n\n#wovn-translate-widget[wovn] h6:after {\n    content: \' \';\n    position: absolute;\n    top: .7em;\n    right: .85em;\n    width: 0;\n    height: 0;\n    border-top: .35em solid #6c7984;\n    border-right: .25em solid transparent;\n    border-left: .25em solid transparent;\n}\n\n#wovn-translate-widget[wovn].mobile h6:after {\n    border-top: 6px solid #6c7984;\n    border-right: 4px solid transparent;\n    border-left: 4px solid transparent;\n    margin-top: -2px;\n    right: 8px;\n    top: 50%;\n}\n\n#wovn-translate-widget[wovn] #wovn-content > a {\n    position: absolute;\n    display: block;\n    top: 5px;\n    right: 7px;\n    bottom: 0;\n    left: auto;\n    width: 77px;\n    margin: 0;\n    padding: 0;\n}\n#wovn-translate-widget[wovn].mobile #wovn-content > a {\n    width: 40%;\n    top: 0;\n    right: 0;\n    left: auto;\n    margin: .5em;\n    background: url(https://s3-us-west-1.amazonaws.com/st.wovn.io/images_store/wovn_widget_logo.svg) no-repeat right;\n    -webkit-background-size: auto 100%;\n    background-size: auto 75%;\n    text-align: center;\n    height: 34px;\n}\n#wovn-translate-widget[wovn] #wovn-content > a #wovn-logo {\n    position: relative;\n    display: inline-block;\n    width: 77px;\n    height: 18px;\n    top: 5px;\n    background: url(https://s3-us-west-1.amazonaws.com/st.wovn.io/images_store/wovn_widget_logo.png) no-repeat;\n}\n#wovn-translate-widget[wovn] #wovn-content > div#translated-by-machine {\n    box-sizing: initial;\n    position: absolute;\n    display: none;\n    width: 100px;\n    height: 10px;\n    bottom: 8%;\n    background: url(https://s3-us-west-1.amazonaws.com/st.wovn.io/images_store/wovn_widget_text.png) no-repeat;\n}\n\n/* tbm, yes logo, no mobile*/\n#wovn-translate-widget[wovn].show-tbm #wovn-content {\n  padding-bottom: 1.65em;\n}\n#wovn-translate-widget[wovn].show-tbm.position-top-left #wovn-content > div#translated-by-machine {\n    box-sizing: initial;\n    right: 0px;\n}\n#wovn-translate-widget[wovn].show-tbm.position-bottom-left #wovn-content > div#translated-by-machine {\n    box-sizing: initial;\n    right: 0px;\n}\n\n/*tbm, yes logo, yes mobile*/\n#wovn-translate-widget[wovn].show-tbm.mobile #wovn-content {\n  padding-bottom: .45em;\n}\n#wovn-translate-widget[wovn].show-tbm.mobile #wovn-content > div#translated-by-machine {\n    box-sizing: initial;\n    right: 0.3em;\n    width: 4.7em;\n    height: auto;\n    top: 0;\n    bottom: 0;\n    background-position: 100% 86%;\n    background-size: 100%;\n}\n#wovn-translate-widget[wovn].show-tbm.mobile #wovn-content > a {\n    background-position: right top;\n    background-size: auto 60%;\n    margin: 0.3em;\n}\n\n/*tbm, no logo, yes mobile*/\n#wovn-translate-widget[wovn].show-tbm.mobile.hide-logo #wovn-content {\n}\n#wovn-translate-widget[wovn].show-tbm.mobile.hide-logo #wovn-content > div#translated-by-machine {\n    box-sizing: initial;\n    right: 0.3em;\n    width: 4.7em;\n    height: auto;\n    top: 0;\n    bottom: 0;\n    background-position: right;\n    background-size: 100%;\n}\n#wovn-translate-widget[wovn].mobile #wovn-content > a #wovn-logo {\n    display: none\n}\n#wovn-translate-widget[wovn] div.wovn-lang-list-container {\n    font-size: 12px !important;\n    display: none;\n    position: absolute;\n    bottom: 2.1em;\n    left: 0;\n}\n#wovn-translate-widget[wovn].mobile div.wovn-lang-list-container {\n    font-size: 12px !important;\n    bottom: 36px;\n    width: 100%;\n}\n\n#wovn-translate-widget[wovn] ul {\n    z-index: 1;\n    max-height: 290px;\n    position: relative;\n    left: -11px;\n    right: 3px;\n    width: auto;\n    margin: 0;\n    padding: 0;\n    font-size: 1em;\n    background: white;\n    overflow-y: auto;\n    overflow-x: hidden;\n    border: 1px solid #dee5ec;\n    border-radius: 3px;\n    -webkit-box-shadow: 0 0 3px 3px rgba(0, 0, 0, .04);\n    -moz-box-shadow: 0 0 3px 3px rgba(0, 0, 0, .04);\n    box-shadow: 0 0 3px 3px rgba(0, 0, 0, .04);\n}\n#wovn-translate-widget[wovn].mobile ul {\n    top: auto !important;\n    left: 0;\n}\n#wovn-translate-widget[wovn] li {\n    position: relative;\n    list-style-type: none;\n    float: none;\n    width: auto;\n    padding: 10px 8px 10px 28px;\n    line-height: 16px;\n    text-transform: none;\n    border: none;\n    border-radius: 0;\n    font-weight: normal;\n    font-family: Verdana, sans-serif;\n    font-size: 1em;\n    font-style: normal;\n    color: #82959f;\n    white-space: nowrap;\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -khtml-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n#wovn-translate-widget[wovn].mobile li {\n    padding: 0 8px 0 24px;\n    line-height: 40px;\n    text-align: left;\n    height: 40px;\n}\n#wovn-translate-widget[wovn] li:hover {\n    background: #f6f8fa;\n}\n#wovn-translate-widget[wovn] li.selected:before {\n    content: \' \';\n    width: 8px;\n    height: 8px;\n    position: absolute;\n    left: 10px;\n    top: 14px;\n    border-radius: 4px;\n    background: #46b77e;\n}\n\n#wovn-translate-widget[wovn] li.selected {\n    color: #545f66;\n}\n\n#wovn-translate-widget[wovn].mobile li.selected:before {\n    margin-top: -4px;\n    left: 8px;\n    top: 50%;\n}\n#wovn-translate-widget[wovn] h6 > img {\n    position: absolute;\n    display: block;\n    top: 9px;\n    right: 10px;\n    width: 6px;\n    height: 4px;\n    border: none;\n    border-radius: 0;\n}\n#wovn-translate-widget[wovn].mobile h6 > img {\n    display: none;\n}\n\n#wovn-translate-widget[wovn] p {\n    margin: 0;\n    padding: 2px 0 4px 4px;\n    line-height: 9px;\n    font-size: 9px;\n    font-family: Verdana, sans-serif;\n    color: #c5cfd9;\n}\n\n#wovn-translate-widget[wovn] p span {\n    font-size: 9px;\n    font-family: Verdana, sans-serif;\n    color: #6c7984;\n}\n\n#wovn-translate-widget[wovn] {\n    -webkit-animation: desktop-slide-in .5s;\n    animation: desktop-slide-in .5s;\n}\n\n#wovn-translate-widget[wovn].mobile.slide-in {\n    -webkit-animation: slidein .2s;\n    animation: slidein .2s;\n}\n\n#wovn-translate-widget[wovn].slid-out {\n    bottom: -3em;\n    opacity: 0;\n}\n\n#wovn-translate-widget[wovn].mobile.slide-out {\n    -webkit-animation: slideout .5s;\n    animation: slideout .5s;\n}\n\n@-webkit-keyframes desktop-slide-in {\n    0% {\n        right: -100%;\n    }\n    100% {\n        right: 0;\n    }\n}\n@keyframes desktop-slide-in {\n    0% {\n        right: -100%;\n    }\n    100% {\n        right: 0;\n    }\n}\n@-webkit-keyframes desktop-slide-in-left {\n    0% {\n        left: -100%\n    }\n    100% {\n        left: 0;\n    }\n}\n@keyframes desktop-slide-in-left {\n    0% {\n        left: -100%\n    }\n    100% {\n        left: 0;\n    }\n}\n\n#wovn-translate-widget.mobile.slide-out {\n    -webkit-animation: slideout .5s;\n    animation: slideout .5s\n}\n\n@-webkit-keyframes slidein {\n    0% {\n        bottom: -3em;\n        opacity: 0;\n    }\n    50% {\n        opacity: 1;\n    }\n    100% {\n        bottom: 0;\n    }\n}\n@keyframes slidein {\n    0% {\n        bottom: -3em;\n        opacity: 0;\n    }\n    50% {\n        opacity: 1;\n    }\n    100% {\n        bottom: 0;\n    }\n}\n@-webkit-keyframes slideout {\n    0% {\n        bottom: 0;\n        opacity: 1;\n    }\n    100% {\n        bottom: -3em;\n        opacity: 0;\n    }\n}\n@keyframes slideout {\n    0% {\n        bottom: 0;\n    }\n    50% {\n        opacity: 1;\n    }\n    100% {\n        bottom: -3em;\n        opacity: 0;\n    }\n}\n"
    that.insertStyles(styles);
    widgetElement = document.createElement('div');
    widgetElement.id = 'wovn-translate-widget'
    widgetElement.setAttribute('wovn', '');
    widgetElement.innerHTML = '<div id="wovn-collapse-btn"></div><div id="wovn-content"><div id="background"></div><h6><div class="wovn-lang-list-container"><ul class="wovn-lang-list"></ul></div><span class="wovn-current-lang">Loading...</span></h6><a href="http://wovn.io" target="_blank"><div id="wovn-logo"></div></a><div id="translated-by-machine"></div></div></div>';
    document.body.appendChild(widgetElement);
    appendedChildren.push(widgetElement);

    var clickCatcher = document.createElement('div');
    clickCatcher.setAttribute('style', 'z-index:9999999999;position:fixed;display:none;top:0;right:0;bottom:0;left:0;background:transparent;');
    onEvent(clickCatcher, 'click', closeDropDown);
    widgetElement.parentNode.insertBefore(clickCatcher, widgetElement);

    var dropDownButton = widgetElement.getElementsByTagName('h6')[0];

    onEvent(dropDownButton, 'click', openDropDown);

    if (widget.c('Agent').isMobile()) {
      widgetElement.className += ' mobile slide-in';
      rescaleWidget(widgetElement);

      onEvent(window, 'scroll', showWidget);

      if (window.navigator.msPointerEnabled) {
        // Pointer events are supported.
        onEvent(window, 'pointerup', function (e) {
          if (e.buttons === 0)
            rescaleWidget(widgetElement);
        });
      }
      else {
        onEvent(window, 'touchend', function (e) {
          if (e.touches.length === 0)
            rescaleWidget(widgetElement);
        });
      }

      if (!widget.c('Utils').pageIsWidgetPreview()) {
        widgetTimeout = setTimeout(animHideWidget, 5000);
      }
    }

    function openDropDown () {
      var e = arguments[0] || window.event;
      if (e.stopPropagation)
        e.stopPropagation();
      else
        e.returnValue = false;
      if (dropDownButton.firstChild.style.display == 'block') {
        dropDownButton.firstChild.style.display = 'none';
        clickCatcher.style.display = 'none';
      }
      else {
        dropDownButton.firstChild.style.display = 'block';
        clickCatcher.style.display = 'block';
      }
    }

    function closeDropDown () {
      var e = arguments[0] || window.event;
      if (e.stopPropagation)
        e.stopPropagation();
      else
        e.returnValue = false;
      dropDownButton.firstChild.style.display = 'none';
      clickCatcher.style.display = 'none';
    }

    widgetElement.setAttribute('data-ready', widget.tag.getAttribute('data-wovnio') + '&ready=true');
    //if (translating) widgetElement.style.display = 'none';
    applyWidgetOptions();

    //var widget = document.getElementById(that.WIDGET_ID);
    that.refresh(widgetElement);
  };

  this.getWidgetElement = function () {
    return document.getElementById(that.WIDGET_ID);
  };

  var clearWidgetLangList = function() {
    var widgetElement = that.getWidgetElement();
    if (!widgetElement) return;
    var listItems = widget.c('Utils').toArrayFromDomList(widgetElement.getElementsByTagName('li'));
    for (var i = 0; i < listItems.length; ++i) listItems[i].parentNode.removeChild(listItems[i]);
  };

  this.refresh = function () {
    var widgetElement = that.getWidgetElement();
    if (!widgetElement) return;
    // TODO: reset the lang list and/or remove unused/duplicate languages
    if (wovnGetElementsByClassName(widgetElement, 'wovn-switch').length === 0) {
      buildWidgetLangList(widget.c('Lang').getConvertedLangs());
      attachLangClickHandlers();
    }

    if (wovnGetElementsByClassName(widgetElement, 'wovn-switch').length > 1 && !widget.c('ValueStore').empty()) {
      // TODO: THIS SEEMS LIKE THE WRONG WAY TO DO THIS?
      if (!/wovn\.editing/.test(location.hash))
        widgetElement.style.display = 'block';
      disableBrowserTranslation();
    }
    else
      widgetElement.style.display = 'none';
  };

  /**
   * start wovn's main function
   * @param {Function} callback called when succeed
   */
  this.start = function(callback) {
    // if the browser is a web crawler, do nothing
    if (widget.c('Agent').isCrawler()) return;
    // shims
    widget.c('Utils');
    // load data
    loadData(init);
    widget.c('PerformanceMonitor').mark('data_load_script_insert');

    function init () {
      if (!widget.c('Data').getImageValues) widget.c('Data').getImageValues = function() {return {}};
      if (!widget.c('Data').getTextValues) widget.c('Data').getTextValues = function() {return {}};
      widget.c('PerformanceMonitor').mark('data_load_end');
      if (widget.c('Data').useImmediateWidget()) {
        widget.c('Utils').onDomReady(widgetOnLoadedDocument, true);
      } else {
        widget.c('Utils').onLoadingComplete(widgetOnLoadedDocument);
      }

      // waits for the page to be loaded before creating the widget
      function widgetOnLoadedDocument() {
        insertHreflangLinks();
        widget.c('Interface').build();
        // loads API
        widget.c('Api');
        // lang will set doc lang
        if (widget.c('Url').isLiveEditor()) {
          // Use original language for LiveEditor's initialization.
          widget.c('Lang').setDocLang(widget.c('Data').getLang());
        }
        else {
          widget.c('Lang').setDocLang();
        }
        widget.c('AuditTrigger').start();
        widget.c('SPA').listen();
        widget.c('ViewAnalytics').start();
        widget.c('Api').dispatchWovnApiReadyEvent();
        if (callback) callback();
        widget.c('PerformanceMonitor').mark('first_translation_finish');
        if (widget.c('Url').isLiveEditor()) {
          widget.c('Interface').changeLang('ed');
        }
      }
    }
  };

  /**
   * Add the hreflang tags to the page
   */
  function insertHreflangLinks() {
    var prerender_io = widget.c('Data').getOptions().prerender_io;
    if (prerender_io) {
      widget.c('Data').updateOptions({lang_path: 'query'})
    }
    var langPath = widget.c('Data').getOptions().lang_path;
    if (!widget.isBackend() && (langPath === 'query' || langPath === 'path' || langPath === 'subdomain')) {
      var defaultCode = widget.c('Lang').defaultCode();
      var availableLanguages = widget.c('Data').getPublishedLangs();
      availableLanguages.push(defaultCode);
      var insertionLocation = document.getElementsByTagName('head').length > 0 ? document.getElementsByTagName('head')[0] : null;

      if (insertionLocation) {
        for(var i = 0; i < availableLanguages.length; i++) {
          if (availableLanguages[i]) {
            var langUrl = widget.c('Url').getUrl(availableLanguages[i], document.location.href);
            var link = document.createElement('link');
            link.rel = 'alternate';
            link.hreflang = widget.c('Lang').iso6391Normalization(availableLanguages[i]);
            link.href = langUrl;
            insertionLocation.appendChild(link);
          }
        }
      }
    }
  }

  /**
   * get Data-related data and callback when all information cllected
   * @param {Function} callback called when all information cllected
   */
  function loadData(callback) {
    var remainCount = 2;

    var optionData = {};

    that.loadData(function(data) {
      widget.c('Data').set(data);
      successCallback();
    })

    widget.loadDomainOption(function(option) {
      optionData = option;
      successCallback();
    }, function() {});

    // if error occured, callback won't executed.
    function successCallback() {
      remainCount--;

      if (remainCount == 0) {
        widget.c('Data').setOptions(optionData);
        callback();
      }
    }
  }

  this.loadData = function (callback) {
    var isLiveEditor = widget.c('Url').isLiveEditor();
    if (isLiveEditor) {
      widget.loadSavedData(function(data) {
        callback(data);
      }, function() {
        alert("Failed to load wovn's data. please reload.")
      });
    } else {
      widget.loadDataJson(function(data) {
        callback(data);
      });
    }
  }

  /**
   * Reload Data component for SPA
   */
  this.reload = function() {
    var options = widget.c('Data').getOptions();
    widget.c('DomAuditor').stop();
    widget.c('AuditTrigger').stop();
    widget.c('SPA').stop();
    widget.c('ViewAnalytics').stop();
    widget.reloadData(function(data) {
      // Set options simultaneously to avoid race condition.
      data['widgetOptions'] = options;
      widget.c('Data').set(data);
      widget.reinstallComponent('ValueStore');
      widget.reinstallComponent('AuditTrigger');
      widget.reinstallComponent('DomAuditor');
      clearWidgetLangList();
      widget.c('Interface').refresh();
      widget.c('AuditTrigger').start();
      widget.c('SPA').listen();
      widget.c('ViewAnalytics').start();
    });
  };

  this.destroy = function () {
    for (var i = 0; i < attachedHandlers.length; i++) {
      widget.c('Utils').removeHandler(attachedHandlers[i].target, attachedHandlers[i].eventName, attachedHandlers[i].handler);
    }
    for (var i = 0; i < appendedChildren.length; i++) {
      if (appendedChildren[i].parentNode) appendedChildren[i].parentNode.removeChild(appendedChildren[i]);
    }
  };
};

if (typeof(components) === 'undefined') var components = {};
components['Api'] = function (widget) {
  var that = this;
  // dispatched when language is changed
  var langChangedEvent = widget.c('Utils').createInitEvent('wovnLangChanged', true, true);

  // dispatched when WOVN API is ready
  var wovnApiReadyEvent = widget.c('Utils').createInitEvent('wovnApiReady', true, true);

  // Create WOVN.io object
  WOVN = {};
  WOVN.io = {};
  WOVN.io.changeLang = function (lang) {
    var langCode = widget.c('Lang').getCode(lang);

    // invalid lang
    if (!langCode) return false;

    widget.c('Interface').changeLang(langCode);
    return true;
  };

  WOVN.io.getCurrentLang = function () {
    return getCurrentLang();
  };

  WOVN.io.getWovnUrl = function (url) {
    var lang = widget.c('Lang').getActualLang()
    return widget.c('Url').getUrl(lang, url)
  }

  WOVN.io.swap = function(element) {
    var lang = getCurrentLang()
    if (!lang) return

    var langCode = lang.code
    if (element) {
      widget.c('DomAuditor').swapVals(langCode, {head: element}, true)
    } else {
      widget.c('DomAuditor').swapVals(langCode, {}, true)
    }
  }

  WOVN.io.translateTexts = function(fromLang, toLang, texts) {
    return widget.c('ValueStore').translateTexts(fromLang, toLang, texts);
  }

  WOVN.io._private = {
    widget: widget
  }

  this.dispatchLangChangedEvent = function () {
    widget.c('Utils').dispatchEvent(langChangedEvent);
  };

  function getCurrentLang() {
    return widget.c('Lang').get(widget.c('Lang').getDocLang());
  }

  // Create Wovnio object for backwards compatibility
  Wovnio = WOVN.io;

  // Dispatch API loaded event
  this.dispatchWovnApiReadyEvent = function () {
    widget.c('Utils').dispatchEvent(wovnApiReadyEvent);
    // only allow this event to be called once
    that.dispatchWovnApiReadyEvent = function () {
    };
  };
};

if (typeof(components) === 'undefined') var components = {};
components['SPA'] = function(widget) {
  var that = this;
  var timer = undefined;

  widget.c('Utils').onEvent(window, 'popstate', function () {
    var langPath = widget.c('Data').getOptions().lang_path;
    if ((langPath === 'query' || langPath === 'path' || (widget.isBackend() && widget.tag.getAttribute('urlPattern'))) && widget.c('Lang').getDocLang() !== widget.c('Url').getLangCode()) {
      widget.c('Interface').changeLang(widget.c('Url').getLangCode());
    }
  });

  var fixHref = function(href) {
    return widget.c('Url').removeHash(href);
  };

  this.getCurrentFixedHref = function () {
    return fixHref(location.href);
  }

  var lastHref = null;
  this.listen = function() {
    if (!lastHref) {
      lastHref = that.getCurrentFixedHref();
    }
    timer = setInterval(function() {
      var currentHref = that.getCurrentFixedHref();
      // if url hasn't changed OR new url is the result of a lang change(from the old url)
      if (lastHref === currentHref || 
      currentHref === widget.c('Url').getUrl(widget.c('Url').getLangCode(currentHref), lastHref))
        return;
      lastHref = currentHref;
      widget.c('Interface').reload();
    }, 100);
  };

  this.stop = function() {
    clearInterval(timer);
  };

  this.destroy = function() {
    that.stop();
  };
};

// FIXME use cookies instead???
if (typeof(components) === "undefined") var components = {};
components["ViewAnalytics"] = function (widget) {
  var that = this;
  var viewAnalytics;

  this.get = function () {
    return viewAnalytics;
  };

  this.start = function () {
    viewAnalytics = {
      token: widget.tag.getAttribute("key"),
      url: decodeURIComponent(widget.c("Url").getEncodedLocation(location.href)),
      timestamp: (new Date()).toString(),
      fingerprint: viewFingerprint = widget.c("Utils").getBrowserFingerprint(),
      selectedLanguages: [widget.c("Lang").getDocLang()]
    };

    if (viewAnalytics.token !== "false") {
      // record selected languages on language changed
      widget.c('Utils').addEventListener("wovnLangChanged", this.onLanguageChanged);
      // send view analytics when the window/tab is closed or reloaded
      widget.c("Utils").onEvent(window, "beforeunload", this.deliverViewAnalytics);
      widget.c("Utils").onEvent(window, "beforereload", this.deliverViewAnalytics);
    }
  };

  this.stop = function () {
    var wovnSwitches = document.getElementsByClassName("wovn-switch");

    document.removeEventListener("wovnLangChanged", this.onLanguageChanged);
    widget.c("Utils").removeHandler(window, "beforeunload", this.deliverViewAnalytics);
    widget.c("Utils").removeHandler(window, "beforereload", this.deliverViewAnalytics);

    this.deliverViewAnalytics();
  };

  this.deliverViewAnalytics = function () {
    var request = new XMLHttpRequest();
    var host = "//view-analytics.wovn.io/".replace(/^.*\/\//, "//");
    var jsonViewAnalytics = JSON.stringify(viewAnalytics, null, 4);
    var postBody = "viewAnalytics=" + encodeURIComponent(jsonViewAnalytics);
    var action = "view_analytics/deliver_view_analytics";

    request.open("POST", host + action, true);
    request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    request.send(postBody);
  };

  this.onLanguageChanged = function () {
    var selectedLangCode = widget.c("Lang").getDocLang();

    if (widget.c('Utils').indexOf(viewAnalytics.selectedLanguages, selectedLangCode) == -1) {
      viewAnalytics.selectedLanguages.push(selectedLangCode);
    }
  }
};

if (typeof(components) === 'undefined') var components = {};
components['PerformanceMonitor'] = function(widget) {
  //This component allow using newest function, because this is for special environment.
  var performanceResults = {
    'page_request_start': null,
    'page_response_end': null,
    'wovn_js_request_start': null,
    'wovn_js_response_end': null
  };
  var markPrefix = 'wovn_';
  var that = this;

  this.mark = function(name) {
    if(that.isMonitorable == false) return;

    var markName = markPrefix + name;
    //performance.mark(markName);
    if (performanceResults[markName] == undefined || performanceResults[markName] == null) {
      performanceResults[markName] = new Date().getTime();
    }
  };

  this.getResult = function() {
    if(that.isMonitorable == false) return {};

    var keys = Object.keys(performanceResults);

    var result = {};
    for(var i = 0; i < keys.length; i++) {
      var originalKey = keys[i];
      var key = originalKey;
      if(new RegExp(markPrefix).test(key)) {
        key = key.substring(markPrefix.length);
      }
      result[key] = performanceResults[originalKey];
    }
    return result;
  };

  this.isMonitorable = false;

  this.resetIsMonitorable = function() {
    if(widget.c('Cookie').get('wovn_monitor_enable') === 'true') {
      that.isMonitorable = true;
    } else {
      that.isMonitorable = false;
    }
  };

  initIsMonitorable();
  function initIsMonitorable() {
    that.resetIsMonitorable();
  }
};

// Original Cookie code from http://developers.livechatinc.com/blog/setting-cookies-to-subdomains-in-javascript/
if (typeof(components) === 'undefined') var components = {};
components['Config'] = function (widget) {
  var that = this;

  this.urlPattern = function (test) {
    var urlPattern;
    if (widget.tag.getAttribute('urlPattern'))
      urlPattern = widget.tag.getAttribute('urlPattern');
    else if (widget.c('Data').getOptions().lang_path) {
      switch (widget.c('Data').getOptions().lang_path) {
        case 'query':
          urlPattern = 'query';
          break;
        case 'path':
          urlPattern = 'path';
          break;
      }
    }
    return arguments.length === 0 ? urlPattern : urlPattern === test;
  };

  this.backend = function (test) {
    var backend;
    backend = widget.tag.getAttribute('backend') ? true : false;
    return arguments.length === 0 ? backend : backend === !!test;
  };

  this.getSitePrefixPath = function() {
    return getAttributeUsingCache('site_prefix_path');
  }

  var tagCaches = {};
  function getAttributeUsingCache (name) {
    if (!tagCaches.hasOwnProperty(name)) {
      tagCaches[name] = widget.tag.getAttribute(name);
    }
    return tagCaches[name];
  }

  this.setConfig = function (name, val) {
    if (name === 'setConfig') return nil;
    this[name] = val;
    return val;
  };
};

if (typeof(components) === 'undefined') var components = {};
components['PageChecker'] = function (widget) {
  var that = this;

  /**
   * Checks if the page is not found and notify wovn.io if so (only supports
   * pages generated by GET method).
   * First, this function looks for clues that the page might be undefined.
   * Second it sends a request to get window.location and looks for 404 status
   * code in the response header.
   * By doing so, the widget does not always send requests to check if the page
   * is not found, but it only notifies wovn.io if the page is trully not found.
   */
  this.notifyWovnIfNotFound = function () {
    if (pageHasNotFoundClues()) {
      checkPageNotFoundInHeader(function () {
        var xhr = widget.c('Utils').createXHR();
        var apiHost = '//ee.wovn.io/'.replace(/^.*\/\//, "//");
        var notifyUrl = apiHost + 'page_not_found/' + widget.tag.getAttribute('key');

        xhr.open("POST", notifyUrl, true);
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        xhr.send('url=' + widget.c('Url').getEncodedLocation())
      });
    }
  }

  /**
   * Looks for clues that the page might be not found.
   * Clues:
   *   - page title contains 'not found' keyword
   *   - page title contains '404' keyword
   *
   * @return {Boolean} True if there are clues that the page might be not found.
   */
  function pageHasNotFoundClues () {
    return notFoundInTitle() || notFoundInBody();
  }

  /**
   * Sends a request to get the page and applies a given callback if page is not
   * found (only supports pages generated by GET method).
   *
   * @param [Function] callback The function to call if the page is not found.
   */
  function checkPageNotFoundInHeader (notFoundCallback) {
    // only reliable for pages generated by GET method
    widget.c('Utils').sendRequest('HEAD', window.location.href, null, function () {}, function (xhr) {
      if (xhr.status === 404) {
        notFoundCallback();
      }
    });
  }

  var notFoundOccurrences = [
    '404',
    //'غير معثور عليه', // Arabic
    'не е намерена',    // Bulgarian
    '未找到',           // Simplified Chinese
    '未找到',           // Traditional Chinese
    'ikke fundet',      // Danish
    'niet gevonden',    // Dutch
    'not found',        // English
    'ei löydetty',      // Finish
    'pas trouvé',       // French
    'non trouvé',       // French
    'introuvable',      // French
    'nicht gefunden',   // German
    'δεν βρέθηκε',      // Greek
    'לא נמצא',          // Hebrew
    'नहीं मिला',            // Hindi
    'tidak ditemukan',  // Indonesian
    'non trovato',      // Italian
    '見つかりません',   // Japanese
    '찾을 수 없음',     // Korean
    'tidak ditemui',    // Malay
    'ikke funnet',      // Norwegian
    'nie znaleziono',   // Polish
    'não encontrado',   // Portuguese
    'не обнаружена',    // Russian
    'extraviado',       // Spanish
    'no encontrada',    // Spanish
    'hittades inte',    // Swedish
    'ไม่พบ',             // Thai
    'bulunamadı',       // Turkish
    'не знайдено',      // Ukrainian
    'không tìm thấy',   // Vietnamese
  ];
  var notFoundRegExp = new RegExp('(' + notFoundOccurrences.join('|') + ')', 'i');

  /**
   * Checks if there is any occurence of page not found within the title.
   *
   * @return {Boolean} True if the title contains an occurrence of page not
   *                   found text within the title, false otherwise.
   */
  function notFoundInTitle () {
    return document.title.search(notFoundRegExp) !== -1;
  }

  /**
   * Checks if there is any occurence of page not found within the body.
   * This function uses innerText, which is non-standard but supported by
   * Chrome (4+), Firefox (45+), IE (6+), Opera (9.6+), Safari (3+).
   * innerText is useful because it is aware of styling and won't show text from
   * non-displayed nodes.
   *
   * @return {Boolean} True if the title contains an occurrence of page not
   *                   found text within the body, false otherwise.
   */
  function notFoundInBody () {
    var body = document.body;
    var innerText = body.innerText;

    // TODO do not apply this on mobile if there is performance issues???
    return innerText && innerText.search(notFoundRegExp) !== -1;
  }
};


if (typeof(components) === "undefined") var components = {};
components['SwapIntercom'] = function (widget) {
  var MESSAGES = {
    'subscribe': 'WOVNIO_SWAP_INTERCOM_SUBSCRIBE',
    'unsubscribe': 'WOVNIO_SWAP_INTERCOM_UNSUBSCRIBE',
    'acknowledge': 'WOVNIO_SWAP_INTERCOM_ACKNOWLEDGE',
    'swap': 'WOVNIO_SWAP_INTERCOM_SWAP'
  }
  var intercomNode = null;

  this.start = function () {
    if (!widget.c('Utils').pageIsWidgetPreview()) {
      if (this.isMasterIntercom()) {
        intercomNode = this.createParentNode();
      } else {
        intercomNode = this.createChildNode();
      }
      intercomNode.start();
    }
  }

  this.stop = function () {
    intercomNode.stop();
  }

  this.isMasterIntercom = function () {
    return window.self === window.top;
  }

  this.createParentNode = function () {
    return new ParentNode();
  }

  this.createChildNode = function () {
    return new ChildNode();
  }

  function ParentNode() {
    var childNodes = [];

    this.start = function () {
      widget.c('Utils').onEvent(window.self, 'message', listen);
      widget.c('Utils').addEventListener('wovnLangChanged', dispatchSwappingRequestToEveryChild);
    }

    this.stop = function () {
      widget.c('Utils').removeHandler(window.self, 'message', listen);
      document.removeEventListener('wovnLangChanged', dispatchSwappingRequestToEveryChild);
    }

    function listen(event) {
      switch (event.data) {
        case MESSAGES['subscribe']:
          var childNode = event.source;
          var added = addChildNode(childNode);
          if (added) {
            var langCode = widget.c('Lang').getDocLang();
            dispatchSwappingRequest(childNode, langCode);
          }
          break;
        case MESSAGES['unsubscribe']:
          removeChildNode(event.source);
          break;
      }
    }

    function addChildNode(childNode) {
      if (!widget.c('Utils').includes(childNodes, childNode)) {
        childNodes.push(childNode);
        childNode.postMessage(MESSAGES['acknowledge'], '*');

        return true;
      }

      return false
    }

    function removeChildNode(childNode) {
      var childIndex = widget.c('Utils').indexOf(childNodes, childNode);

      if (childIndex >= 0) {
        childNodes.splice(childIndex, 1);

        return true;
      }

      return false;
    }

    function dispatchSwappingRequest(childNode, langCode) {
      if (childNode) {
        childNode.postMessage(MESSAGES['swap'] + ':' + langCode, '*');
      }
    }

    function dispatchSwappingRequestToEveryChild() {
      var langCode = widget.c('Lang').getDocLang();

      for (var i = 0; i < childNodes.length; ++i) {
        dispatchSwappingRequest(childNodes[i], langCode);
      }
    }
  }

  function ChildNode() {
    var parentNode = window.top;
    var subscribeTimeoutID = null;
    var subscriptionTryCount = 0;

    this.start = function () {
      widget.c('Utils').onEvent(window.self, 'message', listen);
      subscriptionTryCount = 0;
      subscribe();
    }

    this.stop = function () {
      widget.c('Utils').removeHandler(window.self, 'message', listen);
      unsubscribe();
    }

    function listen(event) {
      var args = event.data.split(':');
      switch (args[0]) {
        case MESSAGES['acknowledge']:
          clearTimeout(subscribeTimeoutID);
          widget.c('Interface').destroy();
          break;
        case MESSAGES['swap']:
          var langCode = args[1];
          widget.c('Lang').setDocLang(langCode);
          break;
      }
    }

    function subscribe() {
      if (parentNode) {
        subscriptionTryCount += 1;
        parentNode.postMessage(MESSAGES['subscribe'], '*');
        subscribeTimeoutID = setTimeout(subscribe, 1000 * subscriptionTryCount);
      }
    }

    function unsubscribe() {
      clearTimeout(subscribeTimeoutID);
      parentNode.postMessage(MESSAGES['unsubscribe'], '*');
    }
  }
};

if (typeof(components) === 'undefined') var components = {}
components['ParcelForwarding'] = function(widget) {
  var that = this
  var Vue = widget.c('Vue')
  this.banner = null
  this.start = function () {
    widget.c('Interface').insertStyles("div#wovn-tenso-modal {\n  display: none;\n  z-index: 99999999999;\n  position: fixed;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  text-align: center;\n  background: rgba(84,95,102, 0.8);\n  overflow-y: auto;\n  font-family: helvetica, arial, \'hiragino kaku gothic pro\', meiryo, \'ms pgothic\', sans-serif;\n}\n.tenso-img {\n  display: inline-block;\n}\n.raku-ichiban-img {\n  display: none;\n}\n.raku-ichiban .tenso-img {\n  display: none;\n}\n.raku-ichiban .raku-ichiban-img {\n  display: inline-block;\n}\ndiv#wovn-tenso-modal.opened {\n  display: block;\n}\ndiv.wovn-tenso-dialog {\n  width: 652px;\n  height: 396px;\n  position: relative;\n  margin: 7% auto;\n  padding: 24px 25px 16px;\n  display: inline-block;\n  border-radius: 3px;\n  opacity: 1;\n  background-color: #ffffff;\n  box-shadow: 0 19px 38px 0 rgba(0, 0, 0, 0.3), 0 15px 12px 0 rgba(0, 0, 0, 0.22);\n}\ndiv.wovn-tenso-close {\n  position: absolute;\n  width: 32px;\n  top: 16px;\n  right: 0;\n  margin: 9px;\n  line-height: 14px;\n  font-size: 30px;\n  color: #bdc4c8;\n  cursor: pointer;\n}\ndiv.wovn-tenso-header {\n  text-align: center;\n}\ndiv.wovn-tenso-logo {\n  position: absolute;\n  top: 71px;\n  left: 69px;\n}\ndiv.wovn-tenso-title {\n  text-align: center;\n  color: #545f66;\n  font-size: 20px;\n  margin-top: 27px;\n  margin-bottom: 25px;\n  height: 30px;\n}\ndiv.wovn-tenso-lang-selector {\n  display: inline-block;\n  padding: 0 5px;\n}\ndiv.wovn-tenso-lang-selector:after {\n  content: \'|\';\n  color: #8f9aa0;\n  font-size: 16px;\n}\ndiv.wovn-tenso-lang-selector:last-child:after {\n  content: \'\';\n}\nspan.wovn-tenso-lang-selector-name {\n  font-size: 14px;\n  color: #469fd6;\n  cursor: pointer;\n}\nspan.wovn-tenso-lang-selector-name.active {\n  color: #545f66;\n}\ndiv.wovn-tenso-subtitle {\n  text-align: center;\n  font-size: 14px;\n  color: #8f9aa0;\n  margin-bottom: 16px;\n  height: 42px;\n}\ndiv.wovn-tenso-subtitle span {\n  display: block;\n}\ndiv.wovn-tenso-steps {\n  height: 170px;\n  position: relative;\n}\ndiv.wovn-tenso-step {\n  text-align:center;\n  display:inline-block;\n  vertical-align: bottom;\n  width: 160px;\n  height: 140px;\n  margin: 5px 17px;\n  border-radius: 3px;\n  background-color: #ffffff;\n  border: solid 1px #e6e6e6;\n}\ndiv.wovn-tenso-step-content {\n  padding: 5px 10px;\n}\ndiv.wovn-tenso-step-title {\n  padding: 15px 0;\n  font-size: 20px;\n  color: #ff4d09;\n}\n.raku-ichiban div.wovn-tenso-step-title {\n  color: #ab263b;\n}\ndiv.wovn-tenso-step-text {\n  font-size: 14px;\n  color: #545f66;\n}\ndiv.wovn-tenso-step-separator {\n  display: inline-block;\n  color: #ff4d09;\n  position: relative;\n  margin-bottom: 70px;\n}\n.raku-ichiban div.wovn-tenso-step-separator {\n  color: #ab263b;\n}\ndiv.wovn-tenso-footer-border {\n  border-top: 1px solid rgba(0,0,0, 0.12);\n  margin: 2px -25px 0 -25px;\n}\ndiv.wovn-tenso-footer {\n}\ndiv.wovn-tenso-footer-buttons {\n  margin-top: 16px;\n}\ndiv.wovn-tenso-cancel-button {\n  display: inline-block;\n  font-size: 12px;\n  padding: 12px 30px;\n  color: #545f66;\n}\ndiv.wovn-tenso-cancel-button:hover {\n  cursor: pointer;\n}\ndiv.wovn-tenso-ok-button {\n  display: inline-block;\n  font-size: 12px;\n  padding: 12px 30px;\n  color: #ffffff;\n  background-color: #FF4D09;\n  border-radius: 3px;\n}\n.raku-ichiban div.wovn-tenso-ok-button {\n  background-color: #ab263b;\n}\ndiv.wovn-tenso-ok-button:hover {\n  background-color: #FF703A;\n}\n.raku-ichiban div.wovn-tenso-ok-button:hover {\n  background-color: #C55062;\n}\ndiv.wovn-tenso-ok-button:active {\n  background-color: #E54508;\n}\n@media(max-width: 600px) {\n  div.wovn-tenso-step-separator {\n    display:none;\n  }\n  div.wovn-tenso-logo {\n    position: relative;\n    padding-top: 20px;\n    top: initial;\n    left: initial;\n  }\n  div.wovn-tenso-dialog {\n    width: 80%;\n    height: 472px;\n  }\n  div.wovn-tenso-step {\n    width: 100%;\n    height: 61px;\n    margin: 5px auto;\n  }\n  div.wovn-tenso-step-title {\n    margin-top: 5px;\n    padding: 0;\n    font-size: 16px;\n    color: #ff4d09;\n  }\n  div.wovn-tenso-step-text {\n    margin-top: -5px;\n    padding: 8px 0 16px 0;\n    font-size: 11px;\n  }\n  div.wovn-tenso-footer-border {\n    margin: 62px -25px 0 -25px;\n  }\n  div.wovn-tenso-title {\n    margin: 20px 0 0 0;\n    font-size: 16px;\n  }\n  div.wovn-tenso-subtitle {\n    font-size: 12px;\n  }\n  div.wovn-tenso-footer-buttons {\n    margin: 16px 0;\n  }\n}\n@media(max-width: 320px) {\n  div.wovn-tenso-dialog {\n    width: 85%;;\n    height: 478px;\n    padding: 24px 16px 16px;\n  }\n  div.wovn-tenso-subtitle {\n    margin-bottom: 22px;\n  }\n}\n\n/* BANNER */\nbody[wovn-tenso-banner-on] {\n  padding-top: 60px;\n}\ndiv#wovn-tenso-banner {\n  display: none;\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  height: 60px;\n  color: #3991c9;\n  background-color: #b7e2fd;\n  font-family: helvetica, arial, \'hiragino kaku gothic pro\', meiryo, \'ms pgothic\', sans-serif;\n  text-align: center;\n  box-shadow: 0 -1px 3px 0 rgba(0, 0, 0, 0);\n}\ndiv#wovn-tenso-banner.raku-ichiban {\n  color: white;\n  background-color: #ab263b;\n}\ndiv#wovn-tenso-banner.opened {\n  display: block;\n}\na.wovn-tenso-banner-content {\n  display: block;\n  width: 100%;\n  height: 100%;\n  text-decoration: none;\n}\ndiv.wovn-tenso-banner-logo {\n  display: inline-block;\n  top: 14px;\n  position: relative;\n}\n.raku-ichiban div.wovn-tenso-banner-logo {\n  top: 12px;\n  width: 72px;\n  height: 33.9px;\n}\ndiv.wovn-tenso-banner-text {\n  display: inline-block;\n  font-size: 14px;\n  top: 7px;\n  position: relative;\n  padding-left: 10px;\n}\n.raku-ichiban div.wovn-tenso-banner-text {\n  color: #ffffff;\n}\ndiv.wovn-tenso-banner-link {\n  display: inline-block;\n  color: #f95c29;\n  font-size: 16px;\n  top: 7px;\n  position: relative;\n  padding-left: 10px;\n}\n\n.raku-ichiban div.wovn-tenso-banner-link {\n  color: #ffffff;\n}\n\n@media (max-width: 440px) {\n  a.wovn-tenso-banner-content {\n    text-decoration: none;\n  }\n  div.wovn-tenso-banner-logo, .raku-ichiban div.wovn-tenso-banner-logo {\n    display: block;\n    top:9px;\n  }\n  .raku-ichiban div.wovn-tenso-banner-logo {\n    width: auto;\n  }\n  div.wovn-tenso-banner-logo img {\n    width: 90px;\n  }\n  .raku-ichiban div.wovn-tenso-banner-logo img {\n    width: 70px;\n  }\n  div.wovn-tenso-banner-text {\n    top: 8px;\n    font-size: 10px;\n  }\n  div.wovn-tenso-banner-link {\n    top: 8px;\n    padding-left: 0;\n    font-size: 12px;\n  }\n}\n")

    var PARCEL_FORWARDING_LANG_COOKIE = "wovn_parcel_forwarding_lang"
    var provider = widget.c('Data').get()["widgetOptions"]["parcel_forwarding"]
    var providerName = {};
    if (provider === 'raku-ichiban') {
      providerName['ja'] = '楽一番';
      providerName['en'] = 'Leyifan';
      providerName['cht'] = '楽一番';
      providerName['chs'] = '楽一番';
    }
    else {
      providerName['ja'] = '転送コム';
      providerName['en'] = 'Tenso';
      providerName['ko'] = 'tenso.com';
      providerName['cht'] = 'tenso';
      providerName['chs'] = 'tenso';
    }
    var parcelForwardingLangs = [
      {name: '日本', code: 'jp'},
      {name: 'EN', code: 'en'},
      {name: '繁體', code: 'cht'},
      {name: '简体', code: 'chs'},
    ]
    if (provider !== 'raku-ichiban') {
      parcelForwardingLangs.push({name: '한글', code: 'kr'})
    }
    function getParcelForwardingLang(force) {
      var currLang = widget.c('Cookie').get(PARCEL_FORWARDING_LANG_COOKIE)

      if (currLang === null || force) {
        var docLang = widget.c('Lang').getDocLang()

        if (provider === 'raku-ichiban') {
          currLang = 'chs'
        }
        else { //provider == tenso
          currLang = 'en'
        }

        switch (docLang) {
          case 'ja':
            currLang = 'jp'
            break
          case 'zh-CHS':
            currLang = 'chs'
            break
          case 'zh-CHT':
            currLang = 'cht'
            break
          case 'ko':
            if (provider !== 'raku-ichiban') {
              currLang = 'kr'
            }
            break
          case 'en':
            currLang = 'en'
        }

        widget.c('Cookie').set(PARCEL_FORWARDING_LANG_COOKIE, currLang, 365)
      }

      return currLang
    }

    // do not create tenso modal if already shown to user
    if (widget.c('Cookie').get(PARCEL_FORWARDING_LANG_COOKIE) === null) {
      var tensoModal = document.createElement('div')
      tensoModal.id = 'wovn-tenso-modal';
      if (provider == "raku-ichiban") {
        tensoModal.className = 'raku-ichiban';
      }
      tensoModal.setAttribute('wovn-ignore', '')
      tensoModal.innerHTML = "<div class=\"wovn-tenso-dialog\" @click.stop>\n  <div class=\"wovn-tenso-content\">\n    <div class=\"wovn-tenso-close\" @click=\"close\">&times;<\/div>\n    <div class=\"wovn-tenso-header\">\n      <div class=\"wovn-tenso-lang-selector\" v-for=\"lang in languages\">\n        <span v-text=\"lang.name\" @click=\"changeLang(lang)\" :class=\"{ active: lang.code === currentLangCode }\" class=\"wovn-tenso-lang-selector-name\"><\/span>\n      <\/div>\n    <\/div>\n    <div class=\"wovn-tenso-logo\">\n        <img src=\"//wovn.io/assets/tenso_logo_modal.png\" class=\"tenso-img\" alt=\"Tenso\">\n        <img src=\"//wovn.io/assets/raku_ichiban_logo_color.png\" class=\"raku-ichiban-img\" alt=\"Tenso\">\n    <\/div>\n    <div class=\"wovn-tenso-title\">\n      <span v-text=\"textContents[currentLangCode].title\"><\/span>\n    <\/div>\n    <div class=\"wovn-tenso-subtitle\">\n      <span v-text=\"textContents[currentLangCode].subtitle1\"><\/span>\n      <span v-text=\"textContents[currentLangCode].subtitle2\"><\/span>\n    <\/div>\n    <div class=\"wovn-tenso-steps\">\n      <div class=\"wovn-tenso-step\">\n        <div class=\"wovn-tenso-step-content\">\n          <div class=\"wovn-tenso-step-title\">STEP 1<\/div>\n          <div class=\"wovn-tenso-step-text\" v-text=\"textContents[currentLangCode].step1\"><\/div>\n        <\/div>\n      <\/div>\n      <div class=\"wovn-tenso-step-separator\">\n        <img src=\"//wovn.io/assets/tenso_next_step.png\" class=\"tenso-img\" alt=\">\">\n        <img src=\"//wovn.io/assets/raku_ichiban_next_step.png\" class=\"raku-ichiban-img\" alt=\">\">\n      <\/div>\n      <div class=\"wovn-tenso-step\">\n        <div class=\"wovn-tenso-step-content\">\n          <div class=\"wovn-tenso-step-title\">STEP 2<\/div>\n          <div class=\"wovn-tenso-step-text\" v-text=\"textContents[currentLangCode].step2\"><\/div>\n        <\/div>\n      <\/div>\n      <div class=\"wovn-tenso-step-separator\">\n        <img src=\"//wovn.io/assets/tenso_next_step.png\" class=\"tenso-img\" alt=\">\">\n        <img src=\"//wovn.io/assets/raku_ichiban_next_step.png\" class=\"raku-ichiban-img\" alt=\">\">\n      <\/div>\n      <div class=\"wovn-tenso-step\">\n        <div class=\"wovn-tenso-step-content\">\n          <div class=\"wovn-tenso-step-title\">STEP 3<\/div>\n          <div class=\"wovn-tenso-step-text\" v-text=\"textContents[currentLangCode].step3\"><\/div>\n        <\/div>\n      <\/div>\n    <\/div>\n    <div class=\"wovn-tenso-footer-border\"><\/div>\n    <div class=\"wovn-tenso-footer\">\n      <div class=\"wovn-tenso-footer-buttons\">\n        <div class=\"wovn-tenso-cancel-button\" v-text=\"textContents[currentLangCode].cancel\" @click=\"close\"><\/div>\n        <a v-bind:href=\"langLink\" target=\"_blank\"><div class=\"wovn-tenso-ok-button\" v-text=\"textContents[currentLangCode].ok\"><\/div><\/a>\n      <\/div>\n    <\/div>\n  <\/div>\n<\/div>\n";
      tensoModal.setAttribute('v-bind:class', '{opened: opened}')
      tensoModal.setAttribute('v-on:click', 'close')
      document.body.appendChild(tensoModal)
      var tensoModalVue = new Vue({
        el: '#wovn-tenso-modal',
        data: {
          opened: false,
          currentLangCode: getParcelForwardingLang(),
          languages: parcelForwardingLangs,
          textContents: {
            'jp': {
              'title': '簡単に海外発送することができます！',
              'subtitle1': providerName['ja'] + 'を使えば、簡単に海外配送が可能になります。',
              'subtitle2': '日本の通販サイトの商品を、あなたの国へお届けします。登録は無料！',
              'step1': providerName['ja'] + 'に登録して日本の住所をゲット！登録は無料！',
              'step2': '日本の通販サイトでお好きなアイテムを購入',
              'step3': '日本国外へ商品を転送！',
              'cancel': '閉じる',
              'ok': '登録はこちら'
            },
            'en': {
              'title': 'Easily shop in Japan and ship overseas!',
              'subtitle1': 'With ' + providerName['en'] + ', you can easily order products from Japan and have them shipped to your home address in your country.',
              'subtitle2': 'Registration is free!',
              'step1': 'Get a ' + providerName['en'] + ' Japanese mailing address. Registration is free!',
              'step2': 'Purchase your items from any Japanese e-commerce site.',
              'step3': 'Your items will be forwarded from your Japanese address to your overseas address.',
              'cancel': 'Close',
              'ok': 'Register now'
            },
            'cht': {
              'title': '將您購買的商品快速便捷地送往海外！',
              'subtitle1': '利用' + providerName['cht'] + '，將原本困難的海外配送瞬間化為可能',
              'subtitle2': '免費註冊！讓您在日本網站購買的商品被直接送到您家！',
              'step1': '在' + providerName['cht'] + '註冊後即獲得日本地址！註冊免費！',
              'step2': '在日本的網站選購您喜愛的商品',
              'step3': '商品將會從日本國內被送往您所在的國家！',
              'cancel': '關閉',
              'ok': '點擊這裡註冊'
            },
            'chs': {
              'title': '将您购买的商品快速便捷地送往海外！',
              'subtitle1': '利用' + providerName['chs'] + '，将原本困难的海外配送瞬间化为可能',
              'subtitle2': '免费注册！让您在日本网站购买的商品被直接送到家！',
              'step1': '在' + providerName['chs'] + '注册后即获得日本地址！注册免费！',
              'step2': '在日本的网站选购您喜爱的商品',
              'step3': '商品将会从日本国内被送往您所在的国家！',
              'cancel': '关闭',
              'ok': '点击这里注册'
            },
            'kr': {
              'title': '쉽게 해외 배송 수 있습니다!',
              'subtitle1': '전송 컴을 사용하면 쉽게 해외 배송이 가능합니다.',
              'subtitle2': '일본 인터넷 쇼핑몰의 상품을 당신의 국가에 제공합니다. 가입은 무료!',
              'step1': '전송 컴에 가입하고 일본 주소를 겟트! 가입은 무료!',
              'step2': '일본 인터넷 쇼핑몰에서 원하는 상품을 구입',
              'step3': '일본 국외에 상품을 전송!',
              'cancel': '닫기',
              'ok': '등록은 이쪽'
            }
          }
        },
        computed: {
          langLink: function () {
            if (provider == "raku-ichiban") {
              return 'http://www.leyifan.com/' + (this.currentLangCode === 'chs' ? '' : this.currentLangCode)
            }
            else { // provider == tenso
              return 'http://www.tenso.com/' + this.currentLangCode + '/static/lp_shop_index'
            }
          }
        },
        methods: {
          changeLang: function (langObj) {
            this.currentLangCode = langObj.code
            widget.c('Cookie').set(PARCEL_FORWARDING_LANG_COOKIE, this.currentLangCode, 365)
          },
          open: function () {
            this.opened = true
          },
          close: function () {
            this.opened = false
          }
        },
        watch: {
          currentLangCode: function () {
            tensoBannerVue.currentLangCode = this.currentLangCode
          }
        }
      })
      tensoModalVue.open()
    }

    //==========================================================================
    var tensoBanner = document.createElement('div')
    tensoBanner.id = 'wovn-tenso-banner'
    if (provider == "raku-ichiban") {
      tensoBanner.className = 'raku-ichiban';
    }
    tensoBanner.setAttribute('wovn-ignore', '')
    tensoBanner.innerHTML = "<a class=\"wovn-tenso-banner-content\" v-bind:href=\"langLink\" target=\"_blank\">\n  <div class=\"wovn-tenso-banner-logo\">\n      <img src=\"//wovn.io/assets/tenso_logo_banner.png\" class=\"tenso-img\" alt=\"Tenso\">\n      <img src=\"//wovn.io/assets/raku_ichiban_logo_white.png\" class=\"raku-ichiban-img\" alt=\"Tenso\" id=\"banner-image\">\n  <\/div>\n  <div class=\"wovn-tenso-banner-text\" v-text=\"textContents[currentLangCode].bannerText\"><\/div>\n  <div class=\"wovn-tenso-banner-link\" v-text=\"textContents[currentLangCode].link\"><\/div>\n<\/a>\n"
    tensoBanner.setAttribute('v-bind:class', '{opened: opened}')
    document.body.appendChild(tensoBanner)
    var tensoBannerVue = new Vue({
      el: '#wovn-tenso-banner',
      data: {
        opened: false,
        imageSrc:'',
        currentLangCode: tensoModalVue ? tensoModalVue.currentLangCode : getParcelForwardingLang(),
        languages: parcelForwardingLangs,
        textContents: {
          'jp': {
            'bannerText': '海外の顧客、商品を購入するにはこちらをクリック！',
            'link' : 'ここをクリック'
          },
          'en': {
            'bannerText': 'Overseas customers, click here to buy this item!',
            'link' : 'Click Here'
          },
          'cht': {
            'bannerText': '海外客戶，點擊這裡買這個商品！',
            'link' : '點擊這裡'
          },
          'chs': {
            'bannerText': '海外客户，点击这里买这个商品！',
            'link' : '点击这里'
          },
          'kr': {
            'bannerText': '해외 고객이 상품을 구입하려면 여기를 클릭!',
            'link' : '여기를 클릭하세요'
          }
        }
      },
      computed: {
        langLink: function () {
          if (provider == "raku-ichiban") {
            return 'http://www.leyifan.com/' + (this.currentLangCode === 'chs' ? '' : this.currentLangCode)
          }
          else { // provider == "tenso"
            return 'http://www.tenso.com/' + this.currentLangCode + '/static/lp_shop_index'
          }
        }
      },
      methods: {
        changeLang: function () {
          this.currentLangCode = getParcelForwardingLang(true)
          widget.c('Cookie').set(PARCEL_FORWARDING_LANG_COOKIE, this.currentLangCode, 365)
        },
        open: function () {
          document.body.setAttribute('wovn-tenso-banner-on', '')
          this.opened = true
        },
        close: function () {
          this.opened = false
          document.body.removeAttribute('wovn-tenso-banner-on')
        }
      }
    })
    tensoBannerVue.open()
    this.banner = tensoBannerVue
  }
}

if (typeof(components) === 'undefined') var components = {};
components['UnifiedValue'] = function (widget) {
  var cache = {};

  // public function
  this.clearCache = function() {
    cache = {};
  }

  this.swapUnifiedValue = function(rootNode, fromLangCode, toLangCode) {
    var param = setup(fromLangCode, toLangCode);
    if (!param) {
      return;
    }
    fromLangCode = param.fromLangCode;

    var all = traversal(rootNode, param.normalizeText);
    all.tags.forEach(restoreOriginalTag.bind(null, param));
    all.texts.forEach(restoreOriginalText.bind(null, param));

    if (fromLangCode == param.defaultLangCode) {
      all.tags.forEach(storeOriginalTag.bind(null, param));
      all.texts.forEach(storeOriginalText.bind(null, param));

      // report
      all.uvs.forEach(function(uv) {
        // TODO: xpath and is_third_party
        var xpath = 'temp/xpath'
        var is_third_party = false;
        var report = getKey(uv);
        addSrcOfDomAuditor(report, xpath, uv.length > 1, is_third_party, true);
      });
      all.tags.forEach(function(tag) {
        getAttrs(param, tag).forEach(function(attr) {
          var xpath = 'temp/xpath';
          var is_third_party = false;
          var src = tag.getAttribute(attr);
          if (src) {
            addSrcOfDomAuditor(src, xpath, false, is_third_party, false);
          }
        });
      });
    }

    if (toLangCode != param.defaultLangCode) {
      all.tags.forEach(changeTag.bind(null, param));
      all.uvs.forEach(changeUv.bind(null, param));
    }

  }

  // private functions
  function setup(fromLangCode, toLangCode) {
    var url = widget.c('Url');
    var lang = widget.c('Lang');
    var data = widget.c('Data');
    var config = widget.c('Config');
    var utils = widget.c('Utils');
    var parser = widget.c('Parser');
    var valueStore = widget.c('ValueStore');
    var urlFormatter = widget.c('UrlFormatter');
    var translationData = widget.c('TranslationData');

    var defaultLangCode = lang.defaultCode();
    var isLiveEditor = url.isLiveEditor();
    var getUrl = url.getUrl.bind(url);
    var langUrl = url.langUrl.bind(url);
    var shouldIgnoreLink = url.shouldIgnoreLink.bind(url);
    var getSrcValuesFromSrcsetAttribute = valueStore.getSrcValuesFromSrcsetAttribute.bind(valueStore);
    var isUrlPatternQuery = config.urlPattern('query');
    var isBackend = config.backend();
    var normalizeText = utils.normalizeText.bind(utils);
    var createFromUrl = urlFormatter.createFromUrl.bind(urlFormatter);
    var getUrlFromCss = parser.getUrlFromCss.bind(parser);

    // NOTE: when we swapped html with html_swapper, fromLangCode is `unidefied`.
    //       `fromLangCode` is needed when this widget swap html.
    //       but html is already swapped by html_swapper. so we don't need to swap html by widget
    //       In this case, we can return without swapping by widget
    if (!fromLangCode || !toLangCode || fromLangCode == toLangCode) {
      return;
    }

    var textCache = cache.text = cache.text || makeDict(
        defaultLangCode,
        mergeDict(data.getTextValues(), data.getHTMLTextValues()),
        function(ref, src, dst) {
          var html = utils.normalizeText(dst);
          var value = getValueByHtml(html);
          ref[src] = value;
        });
    var imageCache = cache.image = cache.image || makeDict(
        defaultLangCode,
        translationData.calcImgValsForIndex(data.getImageValues()),
        function (ref, src, dst) {
          ref[src] = dst;
        });
    if (!textCache && !imageCache) {
      return;
    }

    return {
      defaultLangCode: defaultLangCode,
      fromLangCode: fromLangCode,
      toLangCode: toLangCode,
      normalizeText: normalizeText,
      createFromUrl: createFromUrl,
      getUrlFromCss: getUrlFromCss,
      fromTextDict: textCache[fromLangCode] || {},
      fromImageDict: textCache[fromLangCode] || {},
      textDict: textCache[toLangCode] || {},
      imageDict: imageCache[toLangCode] || {},
      tags: {
        'a': isLiveEditor ? noop : replaceHref(langUrl, toLangCode),
        'area': isLiveEditor ? noop : replaceHref(langUrl, toLangCode),
        'form': replaceForm(isUrlPatternQuery, isBackend, shouldIgnoreLink, getUrl, toLangCode),
        'img': replaceSrcset(getSrcValuesFromSrcsetAttribute),
      },
      attrs: data.useAriaLabel() ? ['aria-label'] : [],
      tagAttrs: {
        'option': ['label'],
        'optgroup': ['label'],
        'img': ['alt', 'srcset', 'src'],
        'textarea': ['alt', 'placeholder'],
      },
      tagAttrsCondition: {
        'meta': metaAttrs,
        'input': inputAttrs
      }
    };
  }

  function changeTag(param, tag) {
    var name = tag.nodeName.toLowerCase();
    var hit = param.tags[name];
    if (hit) {
      hit(param, tag);
    }

    var attrs = getAttrs(param, tag);
    for (var i=0; i<attrs.length; ++i) {
      var attr = attrs[i];
      var src = tag.getAttribute(attr);
      if (!src) {
        continue;
      }

      var isImage = (name == 'img' && attr == 'src') ||
        name == 'input' && attr == 'src';
      if (isImage) {
        var formatter = param.createFromUrl(src);
        formatter.setShowFullUrl();
        var url = formatter.getOriginalUrl();
        var dst = param.imageDict[url];
        if (!dst) {
          continue;
        }
        tag.setAttribute(attr, dst);

      } else {
        var dst = param.textDict[src];
        if (!dst) {
          continue;
        }
        var value = toText(dst);
        tag.setAttribute(attr, value);
      }
    }

    var background = getBackgroundImage(param, tag);
    if (background) {
      var dst = param.imageDict[background];
      if (dst) {
        tag.style['backgroundImage'] = 'url(' + dst + ')';
      }
    }
  }

  function getBackgroundImage(param, tag) {
    var background = window.getComputedStyle(tag).getPropertyValue('background-image');
    return background && param.getUrlFromCss(background);
  }

  function changeUv(param, uv) {
    var key = getKey(uv);
    var dsts = param.textDict[key];
    if (!dsts) {
      trace('not found', key, param.textDict);
      return;
    }

    unifiedValuesReplace(uv, dsts);
  }

  function unifiedValuesReplace(srcUv, dstTranslation) {
    // Swapper::UnifiedValues::TextReplacer.replace is similar function on ruby
    // https://github.com/WOVNio/html-swapper/pull/31
    var srcs = extractTextNodes(srcUv);
    var dsts = extractTextNodes(dstTranslation);
    if (srcs.length != dsts.length) {
      fail('miss match length');
      return;
    }
    var root = srcUv[0].node.parentNode;
    for (var i=0; i<srcs.length; ++i) {
      var src = srcs[i];
      var dst = dsts[i];
      if (src.isText) {
        src.lookahead.forEach(function (x) { x.nodeValue = ''; });
        var text = dst.isText ? dst.label : "\u200b";
        src.node.nodeValue = dst ? keepWhiteSpace(src.original, text) : "\u200b";
      } else if (dst.isText) {
        var new_node = document.createTextNode(dst.label);
        if (src.isOpen || src.isSentinel) {
          root.insertBefore(new_node, src.node);
        } else if (src.isClose) {
          src.node.appendChild(new_node)
        } else {
          fail('invalid src', src);
        }
        putComment(new_node, '');
      }
    }
  }

  function keepWhiteSpace(src, dst) {
    if (!dst && src.match(/^\s*$/)) {
      return src;
    } else if (src.match(/\s*?\u200b\s*?/)) {
      return src.replace("\u200b", unescapeHtml(dst));
    } else {
      return src.replace(/^(\s*)[\s\S]*?(\s*)$/, function(_, head, tail) {
        return head + (unescapeHtml(dst) || "\u200b") + tail;
      });
    }
  }

  var sentinel_node = {isSentinel: true};

  function extractTextNodes(nodes) {
    // examples:
    //   ['world'] => ['world']
    //   ['<b>', 'world', '</b>'] => [node, 'world', sentinel]
    //   ['hello', '<b>', 'world', '</b>'] => ['hello', 'world', sentinel]
    //   ['hello', '<b>', 'world', '</b>', '.'] => ['hello', 'world', '.']
    //   ['hello', '<br><br>'] => ['hello', '', '']
    if (nodes.length == 0) {
      fail('invlid unified values that it is empty');
      return [];
    }

    var result = [];
    for (var i=0; i<nodes.length; ++i) {
      var node = nodes[i];
      result.push(node);
      if (node.isText) {
        ++i; // next node is tag always, so it can skip
      }
    }
    if (!nodes[nodes.length - 1].isText) {
        result.push(sentinel_node);
    }
    return result;
  }

  function getStoredValue(param, tag, attr) {
    var originalAttr = getAttrForOriginal(attr);
    var original = tag.getAttribute(originalAttr);
    var current = tag.getAttribute(attr);
    var expect = param.fromTextDict[original];
    var isChangeByOther = expect && (expect.label != current);
    return {
      attr: originalAttr,
      value: isChangeByOther ? current || original : original || current
    };
  }

  function storeOriginalTag(param, tag) {
    var attrs = getAttrs(param, tag);
    for (var i=0; i<attrs.length; ++i) {
      var attr = attrs[i];
      var store = getStoredValue(param, tag, attr);
      if (!store.value) {
        continue;
      }
      tag.setAttribute(store.attr, store.value);
    }

    var background = getBackgroundImage(param, tag);
    if (background) {
      var originalAttr = getAttrForOriginal('background-image');
      if (!tag.hasAttribute(originalAttr)) {
        tag.setAttribute(originalAttr, background);
      }
    }
  }

  function restoreOriginalTag(param, tag) {
    var attrs = getAttrs(param, tag);
    for (var i=0; i<attrs.length; ++i) {
      var attr = attrs[i];
      var store = getStoredValue(param, tag, attr);
      if (!store.value) {
        continue;
      }
      tag.setAttribute(attr, store.value);
    }

    var originalAttr = getAttrForOriginal('background-image');
    var background = tag.getAttribute(originalAttr);
    if (background) {
      tag.style['backgroundImage'] = 'url("' + background + '")';
    }
  }

  function storeOriginalText(param, nodes) {
    var node = nodes[0];
    if (node.nodeName == 'TITLE') {
      param.cache.title = param.cache.title || node.data;
      if (nodes.length > 1) {
        fail('too many nodes in title', nodes);
      }
      return;
    }
    putComment(node, nodes.reduce(function (acc, x) { return acc + x.data; }, ''));
  }

  function putComment(node, text) {
    var prev = prevSiblingButIgnoreText(node);
    if(prev && prev.nodeName === '#comment') {
      var comment = prev.data;
      if (comment.indexOf(PREFIX) === 0) {
        return;
      }
    }

    var parentNode = node.parentNode;
    if (parentNode) {
      var comment = document.createComment(PREFIX + text.trim());
      parentNode.insertBefore(comment, node);
    }
  }

  function restoreOriginalText(param, nodes) {
    var node = nodes[0];
    if (node.nodeName == 'TITLE') {
      node.data = param.cache.title;
      if (nodes.length > 1) {
        fail('too many nodes in title', nodes);
      }
      return;
    }

    var prev = prevSiblingButIgnoreText(node);
    if(prev && prev.nodeName === '#comment') {
      var comment = prev.data;
      if (comment.indexOf(PREFIX) === 0) {
        node.data = keepWhiteSpace(node.data, comment.substring(PREFIX.length));
        for (var i=1; i<nodes.length; ++i) {
          nodes[i].data = '';
        }
      }
    }
  }

  function prevSiblingButIgnoreText(node, acc) {
    var prev = node.previousSibling;
    if (prev) {
      if (prev.nodeName == '#text') {
        return prevSiblingButIgnoreText(prev, node);
      } else {
        return prev;
      }
    } else {
      return acc;
    }
  }

  function traversal(target, normalizeText) {
    var tags = [];
    var uvs = [];
    var texts = [];
    var dummy = {nodeName: '', hasAttribute:noop};
    var stack = traversalLoop(dummy, [target], [], normalizeText, tags, texts, uvs);
    if (includesText(stack)) {
      uvs.push(stack);
    }
    return {
      tags: tags,
      texts: texts,
      uvs: uvs
    };
  }

  function traversalLoop(target, nodes, stack, normalizeText, tags, texts, uvs) {
    if (target.id == 'wovn-translate-widget') {
      // ignore wovn widget
      return stack;
    }
    if (target.hasAttribute('wovn-ignore')) {
      return stack;
    }
    var targetName = target.nodeName.toLowerCase();
    var ignoreNodes = NESTED_IGNORE[targetName] || {};

    var len = nodes.length;
    for (var i=0; i<len; ++i) {
      var node = nodes[i];
      var nodeName = node.nodeName.toLowerCase();

      if (ignoreNodes[nodeName]) {
        continue;
      }

      var nodeType = NODE_TYPES[nodeName];
      switch (nodeType) {
        case IGNORE:
          break;

        case TAG:
          tags.push(node);
          break;

        case INLINE:
          tags.push(node);

          stack.push(createOpenTag(node, nodeName));
          stack = traversalLoop(node, node.childNodes, stack, normalizeText, tags, texts, uvs);
          if (!HAS_NOT_CLOSE[nodeName]) {
            stack.push({label: '</' + nodeName + '>', node: node, isClose: true});
          }
          break;

        case TEXT:
          if (trimWithoutZeroWidthSpace(node.data).length == 0) {
            break;
          }
          var result = concatContinuousTextNodes(nodes, i + 1, [node]);
          i += result.skipCount;
          if (result.nodes.length > 0) {
            texts.push(result.nodes);
            result.node = node;
            result.label = result.text.length > 0 ? normalizeText(result.text) : result.text;
            result.isText = true;
            stack.push(result);
          }
          break;

        default:
          // BLOCK and unknown tag are same logic
          tags.push(node);
          if (includesText(stack)) {
            uvs.push(stack);
          }
          stack = [];

          stack = traversalLoop(node, node.childNodes, stack, normalizeText, tags, texts, uvs);
          if (includesText(stack)) {
            uvs.push(stack);
          }
          stack = [];
      }
    }

    if (targetName == 'iframe') {
      try {
        var doc = target.contentDocument; // doc is null if does not load complate
        if (doc) {
          var node = doc.firstChild;
          return traversalLoop(node, node.childNodes, stack, normalizeText, tags, texts, uvs);
        }
      } catch (e) {
        trace(e);
      }
    }

    return stack;
  }

  var metaPropertyDict = {
    'og:description': true,
    'twitter:description': true,
    'og:title': true,
    'twitter:title': true
  };
  function metaAttrs(tag) {
    var name = tag.getAttribute('name');
    var property = tag.getAttribute('property');
    return (name == 'description' || metaPropertyDict[property]) ? ['content'] : [];
  }

  var inputAttrsBase = ['placeholder'];
  var inputAttrDict = {
    search: ['value', 'placeholder'],
    button: ['value', 'placeholder'],
    submit: ['value', 'placeholder'],
    image: ['src', 'alt', 'placeholder'],
  };
  function inputAttrs(tag) {
    var type = tag.getAttribute('type');
    return inputAttrDict[type] || inputAttrsBase;
  }

  function getAttrs(param, tag) {
    var name = tag.nodeName.toLowerCase();
    var all = [];
    function push(x) {
      all.push(x);
    }
    param.attrs.forEach(push);
    (param.tagAttrs[name] || []).forEach(push);
    ((param.tagAttrsCondition[name] || noop)(tag) || []).forEach(push);
    return all;
  }

  function createOpenTag(node, nodeName) {
    var ignore = node.hasAttribute('wovn-ignore');
    var label = ignore ? '<' + nodeName + ' wovn-ignore>' : '<' + nodeName + '>';
    return {label: label, node: node, isOpen: true, ignore: ignore};
  }

  function includesText(stack) {
    return indexOf(stack, function (x) { return x.isText; }) >= 0;
  }

  function addSrcOfDomAuditor(src, xpath, complex, isThirdParty, isUnifiedValue) {
    if (widget.c('Utils').isEmpty(widget.c('Utils').normalizeText(src))) {
      return;
    }

    widget.c('DomAuditor').addSrc(src, xpath, complex, isThirdParty, isUnifiedValue);
  }

  function makeDict(defaultLangCode, input, setFunc) {
    var dict = {};
    for (var src in input) {
      var translation = input[src];
      for (lang in translation) {
        var ref = dict[lang] = dict[lang] || {};
        var data = translation[lang][0].data;
        setFunc(ref, src, data || '');
      }
    }

    return dict;
  }

  function mergeDict() {
    var mergedDict = {};
    for (var i=0; i<arguments.length; ++i) {
      var dict = arguments[i];
      for (var key in dict) {
        mergedDict[key] = dict[key];
      }
    }
    return mergedDict;
  }

  function removeCloseTagInHead(stack) {
    var index = indexOf(stack, function (x) { return !x.isClose });
    return index == -1 ? stack : stack.slice(index, stack.length);
  }

  function removeWovnIgnore(stack) {
    var all = [];
    for (var i=0; i<stack.length; ++i) {
      var item = stack[i];
      if (item.ignore) {
        all.push(item);
        for (++i; i<stack.length; ++i) {
          item = stack[i];
          if (!item.isText) {
            all.push(item);
            break;
          }
        }
      } else {
        all.push(item);
      }
    }
    return all;
  }

  function removeEmptyTag(stack) {
    var consumes = [];
    for (var i=0; i<stack.length; ++i) {
      var item = stack[i];
      if (item.isClose) {
        while (true) {
          var before = consumes[consumes.length - 1];
          if (before && before.isOpen && !before.ignore) {
            --consumes.length;
          }
          break;
        }
      }
      consumes.push(item);
    }
    return consumes;
  }

  function escapeHtml(text) {
    return text.replace(HTML_ESCAPE_REGEX, function(match) {
      return HTML_ESCAPE_MAP[match];
    });
  }

  function unescapeHtml(text) {
    return text.replace('&lt;', '<').
      replace(/&gt;/g, '>').
      replace(/&quot;/g, '"').
      replace(/&#x27;/g, '\'').
      replace(/&#x2F;/g, '/').
      replace(/&amp;/g, '&');
  }

  function getKey(stack) {
    stack = removeCloseTagInHead(stack);
    stack = removeWovnIgnore(stack);
    return stack.map(function(x){ return x.isText ? escapeHtml(x.label) : x.label; }).join('').replace(/\u200b/g, '');
  }

  function toText(dst) {
    return dst.filter(function(x) { return x.isText; }).map(function(x){ return x.label; }).join('');
  }

  function getValueByHtml(html) {
    var texts = html.split(/(<.+?>)/);
    var results = [];
    for (var i=0; i<texts.length; ++i) {
      var text = trimWithoutZeroWidthSpace(texts[i]);
      if (text == '') {
        continue;

      } else if (text[0] == '<') {
        var tagName = text.toLowerCase();
        var value = text[1] == '/' ? {label: tagName, isClose: true} : {label: tagName, isOpen: true, ignore: tagName.indexOf('wovn-ignore') != -1};
        results.push(value);

      } else {
        results.push({label: text, isText: true});
      }
    }
    return results;
  }

  function trimWithoutZeroWidthSpace(x) {
    return x.replace(/^[ \r\n\t]+/, '').replace(/[ \r\n\t]+$/, '');
  }

  function getAttrForOriginal(attr) {
    return 'data-' + PREFIX + '-original-' + attr;
  }

  function replaceHref(langUrl, toLangCode) {
    return function (param, node) {
      var urlWithLang = langUrl(toLangCode, node);
      if (urlWithLang) {
        node.setAttribute('href', urlWithLang);
      }
    }
  }

  function replaceSrcset(getSrcValuesFromSrcsetAttribute) {
    return function (param, node) {
      var srcset = node.getAttribute('srcset');
      if (srcset) {
        var imageUrls = getSrcValuesFromSrcsetAttribute(srcset);
        var newSrcset = srcset;
        for (var imageUrl in imageUrls) {
          var dst = param.imageDict[imageUrl];
          if (dst) {
            var src = imageUrls[imageUrl];
            newSrcset = newSrcset.replace(src, dst);
          }
        }
        if (srcset != newSrcset) {
          node.setAttribute('srcset', newSrcset);
        }
      }
    }
  }

  function replaceForm(isUrlPatternQuery, isBackend, shouldIgnoreLink, getUrl, toLangCode) {
    return function (param, node) {
      // handle forms (for backend)
      var method = node.getAttribute('method');
      if (isUrlPatternQuery && (!method || method.toUpperCase() === 'GET')) {
        var children = node.children;
        // start from the end because the hidden field is inserted at the end
        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i];
          if (child.tagName === 'INPUT' && child.getAttribute('name') === 'wovn' && child.getAttribute('type') === 'hidden') {
            child.setAttribute('value', toLangCode);
            return;
          }
        }

        // input doesn't exist, so create it
        var hiddenField = document.createElement('input');
        hiddenField.setAttribute('type', 'hidden');
        hiddenField.setAttribute('name', 'wovn');
        hiddenField.setAttribute('value', toLangCode);
        node.appendChild(hiddenField);

      } else if (isBackend) {
        var action = node.getAttribute('action');
        var oldAction = !action || action.length === 0 ? location.href : action;
        if (!shouldIgnoreLink(oldAction)) {
          var newAction = getUrl(toLangCode, oldAction);
          node.setAttribute('action', newAction);
        }
      }
    }
  }

  function trace() {}
  function fail() {}

  function noop() {
    // don't delete me
  }

  function concatContinuousTextNodes(inputs, start, init) {
    // there is possibily that text node split by browser, so concat them
    var lookahead = [];
    var skipCount = 0;
    for (var i=start; i<inputs.length; ++i) {
      var node = inputs[i];
      var name = node.nodeName.toLowerCase();
      if (name == "#text") {
        lookahead.push(node);
        ++skipCount;
      } else if (name == "#comment") {
        if (node.data.indexOf(PREFIX) === 0) {
          // `text <!--wovn-src:..--> text` is change node structure by user javascript, so stop concat
          ++skipCount;
          break;
        } else {
          ++skipCount;
        }
        continue;
      } else {
        break;
      }
    }
    var presents = (init.concat(lookahead));
    var text = presents.reduce(function(acc, node) { return acc + node.data; }, '');
    return {
      text: text.trim(),
      original: text,
      nodes: presents,
      lookahead: lookahead,
      skipCount: skipCount
    };
  }

  function indexOf(xs, f, start) {
    start = start || 0;
    for (var i=start; i<xs.length; ++i) {
      var x = xs[i];
      if (f(x)) {
        return i;
      }
    }
    return -1;
  }

  var PREFIX = 'wovn-src:';
  var IGNORE = 1;
  var INLINE = 2;
  var TEXT = 3;
  var TAG = 4;
  var HAS_NOT_CLOSE = {
    'hr': 1,
    'br': 1,
    'img': 1,
  };
  var NESTED_IGNORE = {
    'symbol': {
      'title': true,
      'desc': true,
    }
  };
  var NODE_TYPES = {
    'style': IGNORE,
    'script': IGNORE,
    'fieldset': IGNORE,
    'select': IGNORE,
    'datalist': IGNORE,
    '#comment': IGNORE,

    'optgroup': TAG,

    'a': INLINE,
    'b': INLINE,
    'big': INLINE,
    'i': INLINE,
    'small': INLINE,
    'tt': INLINE,
    'abbr': INLINE,
    'acronym': INLINE,
    'cite': INLINE,
    'code': INLINE,
    'dfn': INLINE,
    'em': INLINE,
    'kbd': INLINE,
    'strong': INLINE,
    'samp': INLINE,
    'time': INLINE,
    'var': INLINE,
    'bdo': INLINE,
    'br': INLINE,
    'map': INLINE,
    'object': INLINE,
    'q': INLINE,
    'span': INLINE,
    'sub': INLINE,
    'sup': INLINE,
    'button': INLINE,
    'input': INLINE,
    'label': INLINE,
    'select': INLINE,
    'textarea': INLINE,
    '#text': TEXT
  };
  var HTML_ESCAPE_REGEX = /[&<>"'\/]/g;
  var HTML_ESCAPE_MAP = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&#x27;',
    '/': '&#x2F;'
  };
};


// expose components so that can be used by the webpack side
document.WOVNIO.components = components;
!function(t){function e(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,e),o.l=!0,o.exports}var n={};e.m=t,e.c=n,e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:r})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=8)}([function(module,exports,__webpack_require__){"use strict";function hasComputedStyle(){return void 0===hasComputedStyleCache&&(hasComputedStyleCache=!!window.getComputedStyle),hasComputedStyleCache}function createJsonHandler(t,e){return function(n,r){if(n){try{var o=JSON.parse(n)}catch(t){return void e()}return void t(o,r)}e()}}function jsonReviver(t,e,n){var r,o,i=t[e];if(i&&"object"==typeof i)for(r in i)Object.prototype.hasOwnProperty.call(i,r)&&(o=jsonReviver(i,r,n),void 0!==o?i[r]=o:delete i[r]);return n.call(t,e,i)}Object.defineProperty(exports,"__esModule",{value:!0});var md5=__webpack_require__(10),domready=__webpack_require__(13),Agent_1=__webpack_require__(2),hasComputedStyleCache=void 0,browserFingerprint,addedEvents=[],wovnEmptyCharacter="​",HTML_ESCAPE_REGEX=/[&<>"'\/]/g,HTML_ESCAPE_MAP={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","/":"&#x2F;"},removesZeroWidthByTrim=void 0,Utils=function(){function Utils(){this.normalizeTextCache={}}return Utils.prototype.pageIsWidgetPreview=function(){return/fake_page\/blank/.test(window.location.pathname)&&/wovn\.(io|com)/.test(window.location.hostname)},Utils.prototype.createInitEvent=function(t,e,n){var r=null;return document.createEvent?(r=document.createEvent("Event"),r.initEvent(t,e,n)):document.createEventObject&&(r=document.createEventObject()),r},Utils.prototype.addEventListener=function(t,e){document.addEventListener?document.addEventListener(t,e):document.createEventObject&&document.attachEvent(t,e)},Utils.prototype.dispatchEvent=function(t){document.dispatchEvent?document.dispatchEvent(t):document.createEventObject&&document.documentElement[t]++},Utils.prototype.getMetaElement=function(t,e){e||(e={});for(var n=document.getElementsByTagName("meta"),r=0;r<n.length;++r)if(n[r].getAttribute("name")===t){var o=!0;for(var i in e)if(e.hasOwnProperty(i)&&e[i]!==n[r].getAttribute(i)){o=!1;break}if(o)return n[r]}return null},Utils.prototype.GetElementsByClassName=function(t,e){if("function"==typeof document.getElementsByClassName)return t.getElementsByClassName(e);for(var n=[],r=new RegExp("(^| )"+e+"( |$)"),o=t.getElementsByTagName("*"),i=0,a=o.length;i<a;i++)(r.test(o[i].className)||r.test(o[i].getAttribute("class")))&&n.push(o[i]);return n},Utils.prototype.canStyleChange=function(t){if(!hasComputedStyle())return!1;if(!t.style)return!1;var e=t.nodeName;return"META"!==e&&("IMG"!==e&&("#text"!==e&&"#comment"!==e))},Utils.prototype.onEvent=function(t,e,n){e=e.replace(/^on(.)/i,function(t,e){return e.toLowerCase()}),t.addEventListener?t.addEventListener(e,n,!1):t.attachEvent&&t.attachEvent("on"+e,n),addedEvents.push([t,e,n])},Utils.prototype.removeHandler=function(t,e,n){t.removeEventListener?t.removeEventListener(e,n,!1):t.detachEvent&&t.detachEvent("on"+e,n)},Utils.prototype.getReadyState=function(){return document.readyState},Utils.prototype.onLoadingComplete=function(t){var e=this;"complete"===this.getReadyState()?t():setTimeout(function(){e.onLoadingComplete(t)},100)},Utils.prototype.onDomReady=function(t){domready(t)},Utils.prototype.sendRequestAsJson=function(t,e,n,r){var o=createJsonHandler(n,r);this.sendRequest(t,e,null,o,r)},Utils.prototype.postJsonRequest=function(t,e,n,r){var o=createJsonHandler(n,r);this.sendRequest("POST",t,e,o,r)},Utils.prototype.createXHR=function(){return window.XDomainRequest?new window.XDomainRequest:new XMLHttpRequest},Utils.prototype.sendRequest=function(t,e,n,r,o){var i;window.XDomainRequest?(i=new window.XDomainRequest,i.onload=function(){r(i.responseText,null)},i.onerror=function(){o()},i.ontimeout=function(){o()}):(i=new XMLHttpRequest,i.onreadystatechange=function(){if(i.readyState===XMLHttpRequest.DONE)if(200===this.status||304===this.status){for(var t={},e=i.getAllResponseHeaders().split("\r\n"),n=0;n<e.length;n++)if(""!==e[n]){var a=e[n].split(": ");t[a[0]]=a[1]}r(i.responseText,t)}else o(i)}),i.open(t,e,!0),n?"object"==typeof n?i.send(this.toJSON(n)):i.send(n):i.send()},Utils.prototype.trimString=function(t){return t.trim&&void 0===removesZeroWidthByTrim&&(removesZeroWidthByTrim=0==="​".trim().length),t.trim&&!1===removesZeroWidthByTrim?t.trim():t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")},Utils.prototype.to_set=function(t){for(var e={},n=0;n<t.length;n++)e[t[n]]=!0;return e},Utils.prototype.isEmpty=function(t){return this.normalizeText(t)===wovnEmptyCharacter},Utils.prototype.toJSON=function(t,e,n){return this.loadsJsonBreakingPrototype()?Object.toJSON(t):this.loadsJsonBreakingMooTools()&&void 0!==JSON.encode?JSON.encode(t):JSON.stringify(t,e,n)},Utils.prototype.loadsJsonBreakingPrototype=function(){return void 0!==window.Prototype&&'["a"]'!==JSON.stringify(["a"])},Utils.prototype.loadsJsonBreakingMooTools=function(){return void 0!==window.MooTools&&'["a"]'!==JSON.stringify(["a"])},Utils.prototype.pushUnique=function(t,e){for(var n=0;n<t.length;n++)if(e==t[n])return;t.push(e)},Utils.prototype.findIndex=function(t,e,n){n=n||function(t,e){return t==e};for(var r=0;r<t.length;r++)if(n(t[r],e))return r;return-1},Utils.prototype.setComplement=function(t,e,n){n=n||function(t,e){return t==e};var r=[];for(var o in t)t.hasOwnProperty(o)&&-1===this.findIndex(e,t[o],n)&&r.push(t[o]);return r},Utils.prototype.getBrowserFingerprint=function(){if(browserFingerprint)return browserFingerprint;var t=window.navigator,e=t.vendor,n=t.userAgent,r=t.hardwareConcurrency,o=t.language,i=t.languages,a=(t.plugins,e||"None"),u=n||"None",s=r||"None",l=o||"None",c=i||[],p=window.screen||{height:"None",width:"None",colorDepth:"None",pixelDepth:"None"},f=a+"::"+u+"::"+s+"::"+l+"::"+c.join()+"::"+function(){for(var t=window.navigator.plugins,e=[],n=0;n<t.length;++n){var r=t[n];e.push(r.name+"-"+r.description+"-"+r.filename)}return e}().join()+"::"+p.height+"::"+p.width+"::"+p.colorDepth+"::"+p.pixelDepth+"::"+(new Date).getTimezoneOffset();return browserFingerprint=md5(f)},Utils.prototype.normalizeText=function(t,e){if(void 0===e&&(e=!1),null===t||void 0===t)return null;if(this.normalizeTextCache[t]){var n=this.normalizeTextCache[t];return e&&n===wovnEmptyCharacter?n="":e||""!==n||(n=wovnEmptyCharacter),n}var r=t;return Agent_1.default.mutatesTextNodeData()&&(r=r.replace(/([^\u0000-\u007F])\n([^\u0000-\u007F])/g,"$1$2")),r=r.replace(/[\n \t\u0020\u0009\u000C\u200B\u000D\u000A]+/g," ").replace(/^[\s\u00A0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]+|[\s\u00A0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]+$/g,""),!1===e&&0===r.length&&(r=wovnEmptyCharacter),this.normalizeTextCache[t]=r,r},Utils.prototype.htmlEscapeText=function(t){return t.replace(HTML_ESCAPE_REGEX,function(t){return HTML_ESCAPE_MAP[t]})},Utils.prototype.extractPath=function(t){var e=t.replace(/^.*?\/\/[^\/]+/,"");return""===e?"/":e},Utils.prototype.toArrayFromDomList=function(t){for(var e=[],n=0;n<t.length;n++)e.push(t[n]);return e},Utils.prototype.keys=function(t){if(Object.keys)return Object.keys(t);var e=[];for(var n in t)t.hasOwnProperty(n)&&e.push(n);return e},Utils.prototype.values=function(t){for(var e=this.keys(t),n=[],r=0;r<e.length;r++)n.push(t[e[r]]);return n},Utils.prototype.each=function(t,e){for(var n=this.keys(t),r=0;r<n.length;r++){var o=n[r];e(o,t[o])}},Utils.prototype.includes=function(t,e){for(var n=0;n<t.length;n++)if(t[n]===e)return!0;return!1},Utils.prototype.indexOf=function(t,e,n){if(t.indexOf)return t.indexOf(e);var r=t.length>>>0;if(0===r)return-1;var o=+n||0;if(1/0===Math.abs(o)&&(o=0),o>=r)return-1;for(o=Math.max(0<=o?o:r-Math.abs(o),0);o<r;o++)if(o in t&&t[o]===e)return o;return-1},Utils.prototype.parseJSON=function(jsonText,reviver){if(JSON&&JSON.parse)return JSON.parse(jsonText);var s=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;s.lastIndex=0,s.test(jsonText)&&(jsonText=jsonText.replace(s,function(t){return"\\u"+("0000"+t.charCodeAt(0).toString(16)).slice(-4)}));var replace=jsonText.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@"),replace2=replace.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]"),s2=replace2.replace(/(?:^|:|,)(?:\s*\[)+/g,"");if(/^[\],:{}\s]*$/.test(s2)){var d=eval("("+jsonText+")");return"function"==typeof reviver?jsonReviver({"":d},"",reviver):d}throw new SyntaxError("JSON.parse")},Utils.prototype.stringStartsWith=function(t,e,n){return n=n||0,t.substr(n,e.length)===e},Utils.prototype.shallowCopy=function(t){if(Object.assign)return Object.assign({},t);var e={};for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n]);return e},Utils.prototype.destroy=function(){for(var t=0;t<addedEvents.length;t++){var e=addedEvents[t];this.removeHandler(e[0],e[1],e[2])}},Utils}();exports.default=new Utils},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=["alt","value","placeholder","content","label"],o=function(){function t(t){this.node=t,this.nodeName=t.nodeName,this.data=t.data}return t.prototype.create=function(e){return new t(e)},t.prototype.getUpperNodeName=function(){if(!this.nodeName)return null;var t=this.nodeName.charCodeAt(1);return!1==(65<=t&&t<=90)?this.nodeName.toUpperCase():this.nodeName},t.prototype.replaceData=function(t,e){this.node.data=t,this.data=t,this.node.actualLang=e},t.prototype.refreshData=function(){var t=this.node.data;t!==this.data&&(this.data=t)},t.prototype.isValueNode=function(){return-1!==r.indexOf(this.nodeName)},t}();e.default=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=void 0,o=window.navigator.userAgent,i=function(){function t(){this.isIEResult=void 0,this.isEdgeResult=void 0}return t.prototype.setAgentString=function(t){o=t},t.prototype.getAgentString=function(){return o},t.prototype.isIE=function(){if(void 0!==this.isIEResult)return this.isIEResult;var t=o.toLowerCase();return this.isIEResult=-1!==t.indexOf("msie")||-1!==t.indexOf("trident"),this.isIEResult},t.prototype.isEdge=function(){return void 0!==this.isEdgeResult?this.isEdgeResult:(this.isEdgeResult=!!o.match(/Edge/),this.isEdgeResult)},t.prototype.isCrawler=function(){return new RegExp("googlebot|slurp|y!j|yahooseeker|bingbot|msnbot|baiduspider|yandex|yeti|naverbot|duckduckbot|360spider|sogou","i").test(o)},t.prototype.isMobile=function(){return!!(o.match(/android/i)&&o.match(/mobile/i)||o.match(/iphone/i)||o.match(/ipod/i)||o.match(/phone/i)||(o.match(/blackberry/i)||o.match(/bb10/i)||o.match(/rim/i))&&!o.match(/tablet/i)||(o.match(/\(mobile;/i)||o.match(/\(tablet;/i)||o.match(/; rv:/i))&&o.match(/mobile/i)||o.match(/meego/i))},t.prototype.mutatesTextNodeData=function(){if(void 0!==r)return r;var t=document.createElement("p");return t.innerHTML="0\n1",r="0\n1"!==t.firstChild.data},t.prototype.canStoreObjectInNode=function(){return!this.isEdge()&&!this.isIE()},t.prototype.isDataHighlighter=function(){return!!o.match(/Google PP Default/)},t}();e.default=new i},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=n(4),o=void 0,i={widgetOptions:{},published_langs:[]},a={},u=function(){function t(){}return t.prototype.getValue=function(t){return i[t]||(this.getOptions()||{})[t]},t.prototype.set=function(t){i=t},t.prototype.setSavedData=function(t){a=t},t.prototype.getSavedData=function(){return a},t.prototype.get=function(){return i},t.prototype.getLang=function(){return i.language},t.prototype.getSecondaryLang=function(){return this.getOptions().secondary_language},t.prototype.getUserId=function(){return i.user_id},t.prototype.getPageId=function(){return i.id},t.prototype.getManualPublishedDate=function(){var t=i.manual_published_time;return t?new Date(1e3*t):null},t.prototype.getTranslationData=function(){var t=this.getTextValues(),e=this.getImageValues(),n=this.getHTMLTextValues();return r.default.create(Date.now(),t,e,n)},t.prototype.getTextValues=function(){return i.text_vals||{}},t.prototype.getHTMLTextValues=function(){return i.html_text_vals||{}},t.prototype.getImageValues=function(){return i.img_vals||{}},t.prototype.getRemovedTextValues=function(){return i.removed_text_vals||[]},t.prototype.getPublishedLangs=function(){return i.published_langs||[]},t.prototype.getTranslatableLangs=function(){return this.getPublishedLangs().concat(this.getLang())},t.prototype.getAutoTranslateLangs=function(){var t=this.getOptions().auto_translate_langs;return t||i.auto_translate_langs},t.prototype.getAutoPublishLangs=function(){var t=this.getOptions().auto_publish_langs;return t||i.auto_translate_langs},t.prototype.getOptions=function(){return i.widgetOptions},t.prototype.setOptions=function(t){i.widgetOptions=t},t.prototype.updateOptions=function(t){i.widgetOptions||(i.widgetOptions={});for(var e in t)t.hasOwnProperty(e)&&(i.widgetOptions[e]=t[e])},t.prototype.getStyleColor=function(){var t=this.getValue("style");if(!t)return null;var e=t.split(" ");return e.length<2?null:e[1]},t.prototype.needsCountryCode=function(t){return t.useCountryData||!1},t.prototype.getCountryCode=function(){if(i.widgetOptions)return this.getOptions().countryCode},t.prototype.browsesFromJapan=function(){return!!i.widgetOptions&&"JP"===this.getOptions().countryCode},t.prototype.setCountryCode=function(t){i.widgetOptions||(i.widgetOptions={}),i.widgetOptions.countryCode=t},t.prototype.dynamicValues=function(){return this.getValue("dynamic_values")||!1},t.prototype.dynamicLoading=function(){return this.getValue("dynamic_loading")||!1},t.prototype.useUnifiedValue=function(){return i.widgetOptions.unified_values},t.prototype.useAriaLabel=function(){return i.widgetOptions.aria_label},t.prototype.useFragmentedValue=function(){return i.widgetOptions.scraping2},t.prototype.numberSwappingAllowed=function(){return i.widgetOptions.number_swapping||!1},t.prototype.useImmediateWidget=function(){return!0===this.getOptions().immediate_widget},t.prototype.createNormalizedHostAliases=function(){if(o)return o;for(var t=this.getOptions().host_aliases||[],e=0;e<t.length;e++)t[e]=t[e].replace(/^\^/,"").replace(/\$$/,"").replace(/\\([^\\])/g,"$1");return o=t,t},t.prototype.clear=function(){o=void 0,i={widgetOptions:{},published_langs:[]},a={}},t}();e.default=new u},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=n(3),o=n(0),i=n(6),a=function(){function t(t,e,n,r){void 0===t&&(t=null),void 0===e&&(e={}),void 0===n&&(n={}),void 0===r&&(r={}),this.creationTime=t,this.textVals=e,this.imgVals=n,this.htmlTextVals=r}return t.prototype.create=function(e,n,r,o){return new t(e,n,r,o)},t.prototype.loadFromStore=function(){var t=Date.now()-36e5,e=r.default.getManualPublishedDate(),n=e?e.getTime():t;return n<t&&(n=t),this.getStoredTranslationValue(n)},t.prototype.getStoredTranslationValue=function(e){var n=i.default.get();if(!n)return new t(Date.now(),{},{},{});var r=this.getStoredTranslation(n,e);return r||new t(Date.now(),{},{},{})},t.prototype.getStoredTranslation=function(e,n){var r=e.getValue("TranslationStore",n);if(!r)return null;var o=r[0],i=r[1];return new t(o,i.text_vals||{},i.img_vals||{},i.html_text_vals||{})},t.prototype.storeToStorage=function(){var t=i.default.get();if(t){var e={text_vals:this.textVals,img_vals:this.imgVals,html_text_vals:this.htmlTextVals};t.setValue("TranslationStore",e,this.creationTime)}},t.prototype.update=function(t){var e=this,n=t.textVals,r=t.imgVals,i=t.htmlTextVals;o.default.each(n,function(t,n){e.textVals[t]=n}),o.default.each(r,function(t,n){e.imgVals[t]=n}),o.default.each(i,function(t,n){e.htmlTextVals[t]=n}),t.creationTime<this.creationTime&&(this.creationTime=t.creationTime)},t.prototype.calcImgValsForIndex=function(t){void 0===t&&(t=null);for(var e=t||this.imgVals,n=/https?:\/\/([^\/:]+)(:[0-9]+)?/,i={},a=o.default.shallowCopy,u=r.default.createNormalizedHostAliases(),s={},l=u.length,c=0;c<l;c++){var p=u[c];p.indexOf(":")>=0&&(p=p.substring(0,p.indexOf(":"))),s[p]=!0}for(var c=0;c<l;c++){var p=u[c],f=p.indexOf(":")>=0,d=f?p:p+"$2";for(var h in e)if(e.hasOwnProperty(h)){var m=h.match(n);if(m){var g=m[1];if(!s[g]){i[h]=a(e[h]);continue}}var v=e[h],y=h.replace(n,d);i["http://"+y]=a(v),i["https://"+y]=a(v);var w=h.replace(n,p);i["http://"+w]=a(v),i["https://"+w]=a(v)}}return i},t}();e.default=new a},function(t,e){var n={utf8:{stringToBytes:function(t){return n.bin.stringToBytes(unescape(encodeURIComponent(t)))},bytesToString:function(t){return decodeURIComponent(escape(n.bin.bytesToString(t)))}},bin:{stringToBytes:function(t){for(var e=[],n=0;n<t.length;n++)e.push(255&t.charCodeAt(n));return e},bytesToString:function(t){for(var e=[],n=0;n<t.length;n++)e.push(String.fromCharCode(t[n]));return e.join("")}}};t.exports=n},function(t,e,n){"use strict";function r(){try{if(window.localStorage)return window.localStorage}catch(t){return null}return null}function o(t){return a+t}Object.defineProperty(e,"__esModule",{value:!0});var i=n(0),a="__wovn__.",u=void 0,s=function(){function t(){this.storage=r()}return t.prototype.get=function(e){return void 0===e&&(e=!1),u&&!e||(u=new t),u.storage?u:null},t.prototype.usable=function(){return!!this.storage},t.prototype.getValue=function(t,e){if(!this.usable())return null;var n=o(t),r=this.getItem(n);if(!r)return null;var i=null;try{i=JSON.parse(r)}catch(t){return this.removeItem(n),null}var a=i.creationTime,u=i.value;return a&&u?a<e||(new Date).getTime()<a?(this.removeItem(n),null):[a,u]:(this.removeItem(n),null)},t.prototype.setValue=function(t,e,n){if(this.usable()){var r={creationTime:n,value:e};this.setItem(o(t),i.default.toJSON(r))}},t.prototype.getItem=function(t){try{return this.storage.getItem(t)}catch(t){return null}},t.prototype.setItem=function(t,e){try{this.storage.setItem(t,e)}catch(e){this.removeItem(t)}},t.prototype.removeItem=function(t){try{this.storage.removeItem(t)}catch(t){}},t}();e.default=new s},function(t,e,n){"use strict";function r(t){var e=t.previousSibling;if(e){if("#text"===e.nodeName)return!0;if(o(e)){var n=e.previousSibling;if(n&&"#text"===n.nodeName)return!0}}var r=t.nextSibling;if(r){if("#text"===r.nodeName)return!0;if(o(r)){var i=r.nextSibling;if(i&&"#text"===i.nodeName)return!0}}return!1}function o(t){return"#comment"===t.nodeName&&i(t.data,u)}function i(t,e){if(t.startsWith)return t.startsWith(e);for(var n=0;n<e.length;n++)if(t.charCodeAt(n)!==e.charCodeAt(n))return!1;return!0}Object.defineProperty(e,"__esModule",{value:!0});var a=n(1),u="wovn-src:",s=function(){function t(){}return t.prototype.isLegitimateNode=function(t){return"#text"!==t.nodeName||!r(t.node)},t.prototype.isFirstTextNode=function(t){for(var e=t;e;){var n=e.previousSibling;if(!n)return!0;if("#text"===n.nodeName){if(!1===/^\s*$/.test(n.data))return!1}else if(0==o(n))return!0;e=n}},t.prototype.disableIllegitimateNode=function(t){if("#text"===t.nodeName)for(var e=t.node.nextSibling;e;){var n=new a.default(e),r=e.nextSibling;if("#text"===n.nodeName)""!==n.data&&n.replaceData("",null);else{if(!o(n))break;e.parentNode.removeChild(e)}e=r}},t.prototype.wholeText=function(t){var e=t.wholeText;if(!e){e="";for(var n=t;n&&"#text"===n.nodeName;)e+=n.data,n=n.nextSibling}return e},t.prototype.getXpath=function(t){var e=[],n=t;for("#text"===t.nodeName&&(e.push("text()"),n=n.parentElement);n&&n.nodeType===Node.ELEMENT_NODE;n=n.parentElement){for(var r=0,o=!1,i=n.previousSibling;i;i=i.previousSibling)i.nodeType!=Node.DOCUMENT_TYPE_NODE&&i.nodeName===n.nodeName&&r++;for(var i=n.nextSibling;i&&!o;i=i.nextSibling)i.nodeName===n.nodeName&&(o=!0);var a=n.nodeName.toLowerCase(),u=r||o?"["+(r+1)+"]":"";e.splice(0,0,a+u)}return e.length?"/"+e.join("/"):null},t}();e.default=new s},function(t,e,n){t.exports=n(9)},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=n(1),o=n(2),i=n(3),a=n(14),u=n(7),s=n(17),l=n(18),c=n(4),p=n(0),f=n(6),d=n(19);document.WOVNIO.components.NodeContainer=r.default,document.WOVNIO.components.Agent=o.default,document.WOVNIO.components.Data=i.default,document.WOVNIO.components.DomIterator=a.default,document.WOVNIO.components.Node=u.default,document.WOVNIO.components.Parser=s.default,document.WOVNIO.components.SingleWorker=l.default,document.WOVNIO.components.Storage=f.default,document.WOVNIO.components.TranslationData=c.default,document.WOVNIO.components.Utils=p.default,document.WOVNIO.components.Wap=d.default},function(t,e,n){!function(){var e=n(11),r=n(5).utf8,o=n(12),i=n(5).bin,a=function(t,n){t.constructor==String?t=n&&"binary"===n.encoding?i.stringToBytes(t):r.stringToBytes(t):o(t)?t=Array.prototype.slice.call(t,0):Array.isArray(t)||(t=t.toString());for(var u=e.bytesToWords(t),s=8*t.length,l=1732584193,c=-271733879,p=-1732584194,f=271733878,d=0;d<u.length;d++)u[d]=16711935&(u[d]<<8|u[d]>>>24)|4278255360&(u[d]<<24|u[d]>>>8);u[s>>>5]|=128<<s%32,u[14+(s+64>>>9<<4)]=s;for(var h=a._ff,m=a._gg,g=a._hh,v=a._ii,d=0;d<u.length;d+=16){var y=l,w=c,b=p,x=f;l=h(l,c,p,f,u[d+0],7,-680876936),f=h(f,l,c,p,u[d+1],12,-389564586),p=h(p,f,l,c,u[d+2],17,606105819),c=h(c,p,f,l,u[d+3],22,-1044525330),l=h(l,c,p,f,u[d+4],7,-176418897),f=h(f,l,c,p,u[d+5],12,1200080426),p=h(p,f,l,c,u[d+6],17,-1473231341),c=h(c,p,f,l,u[d+7],22,-45705983),l=h(l,c,p,f,u[d+8],7,1770035416),f=h(f,l,c,p,u[d+9],12,-1958414417),p=h(p,f,l,c,u[d+10],17,-42063),c=h(c,p,f,l,u[d+11],22,-1990404162),l=h(l,c,p,f,u[d+12],7,1804603682),f=h(f,l,c,p,u[d+13],12,-40341101),p=h(p,f,l,c,u[d+14],17,-1502002290),c=h(c,p,f,l,u[d+15],22,1236535329),l=m(l,c,p,f,u[d+1],5,-165796510),f=m(f,l,c,p,u[d+6],9,-1069501632),p=m(p,f,l,c,u[d+11],14,643717713),c=m(c,p,f,l,u[d+0],20,-373897302),l=m(l,c,p,f,u[d+5],5,-701558691),f=m(f,l,c,p,u[d+10],9,38016083),p=m(p,f,l,c,u[d+15],14,-660478335),c=m(c,p,f,l,u[d+4],20,-405537848),l=m(l,c,p,f,u[d+9],5,568446438),f=m(f,l,c,p,u[d+14],9,-1019803690),p=m(p,f,l,c,u[d+3],14,-187363961),c=m(c,p,f,l,u[d+8],20,1163531501),l=m(l,c,p,f,u[d+13],5,-1444681467),f=m(f,l,c,p,u[d+2],9,-51403784),p=m(p,f,l,c,u[d+7],14,1735328473),c=m(c,p,f,l,u[d+12],20,-1926607734),l=g(l,c,p,f,u[d+5],4,-378558),f=g(f,l,c,p,u[d+8],11,-2022574463),p=g(p,f,l,c,u[d+11],16,1839030562),c=g(c,p,f,l,u[d+14],23,-35309556),l=g(l,c,p,f,u[d+1],4,-1530992060),f=g(f,l,c,p,u[d+4],11,1272893353),p=g(p,f,l,c,u[d+7],16,-155497632),c=g(c,p,f,l,u[d+10],23,-1094730640),l=g(l,c,p,f,u[d+13],4,681279174),f=g(f,l,c,p,u[d+0],11,-358537222),p=g(p,f,l,c,u[d+3],16,-722521979),c=g(c,p,f,l,u[d+6],23,76029189),l=g(l,c,p,f,u[d+9],4,-640364487),f=g(f,l,c,p,u[d+12],11,-421815835),p=g(p,f,l,c,u[d+15],16,530742520),c=g(c,p,f,l,u[d+2],23,-995338651),l=v(l,c,p,f,u[d+0],6,-198630844),f=v(f,l,c,p,u[d+7],10,1126891415),p=v(p,f,l,c,u[d+14],15,-1416354905),c=v(c,p,f,l,u[d+5],21,-57434055),l=v(l,c,p,f,u[d+12],6,1700485571),f=v(f,l,c,p,u[d+3],10,-1894986606),p=v(p,f,l,c,u[d+10],15,-1051523),c=v(c,p,f,l,u[d+1],21,-2054922799),l=v(l,c,p,f,u[d+8],6,1873313359),f=v(f,l,c,p,u[d+15],10,-30611744),p=v(p,f,l,c,u[d+6],15,-1560198380),c=v(c,p,f,l,u[d+13],21,1309151649),l=v(l,c,p,f,u[d+4],6,-145523070),f=v(f,l,c,p,u[d+11],10,-1120210379),p=v(p,f,l,c,u[d+2],15,718787259),c=v(c,p,f,l,u[d+9],21,-343485551),l=l+y>>>0,c=c+w>>>0,p=p+b>>>0,f=f+x>>>0}return e.endian([l,c,p,f])};a._ff=function(t,e,n,r,o,i,a){var u=t+(e&n|~e&r)+(o>>>0)+a;return(u<<i|u>>>32-i)+e},a._gg=function(t,e,n,r,o,i,a){var u=t+(e&r|n&~r)+(o>>>0)+a;return(u<<i|u>>>32-i)+e},a._hh=function(t,e,n,r,o,i,a){var u=t+(e^n^r)+(o>>>0)+a;return(u<<i|u>>>32-i)+e},a._ii=function(t,e,n,r,o,i,a){var u=t+(n^(e|~r))+(o>>>0)+a;return(u<<i|u>>>32-i)+e},a._blocksize=16,a._digestsize=16,t.exports=function(t,n){if(void 0===t||null===t)throw new Error("Illegal argument "+t);var r=e.wordsToBytes(a(t,n));return n&&n.asBytes?r:n&&n.asString?i.bytesToString(r):e.bytesToHex(r)}}()},function(t,e){!function(){var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",n={rotl:function(t,e){return t<<e|t>>>32-e},rotr:function(t,e){return t<<32-e|t>>>e},endian:function(t){if(t.constructor==Number)return 16711935&n.rotl(t,8)|4278255360&n.rotl(t,24);for(var e=0;e<t.length;e++)t[e]=n.endian(t[e]);return t},randomBytes:function(t){for(var e=[];t>0;t--)e.push(Math.floor(256*Math.random()));return e},bytesToWords:function(t){for(var e=[],n=0,r=0;n<t.length;n++,r+=8)e[r>>>5]|=t[n]<<24-r%32;return e},wordsToBytes:function(t){for(var e=[],n=0;n<32*t.length;n+=8)e.push(t[n>>>5]>>>24-n%32&255);return e},bytesToHex:function(t){for(var e=[],n=0;n<t.length;n++)e.push((t[n]>>>4).toString(16)),e.push((15&t[n]).toString(16));return e.join("")},hexToBytes:function(t){for(var e=[],n=0;n<t.length;n+=2)e.push(parseInt(t.substr(n,2),16));return e},bytesToBase64:function(t){for(var n=[],r=0;r<t.length;r+=3)for(var o=t[r]<<16|t[r+1]<<8|t[r+2],i=0;i<4;i++)8*r+6*i<=8*t.length?n.push(e.charAt(o>>>6*(3-i)&63)):n.push("=");return n.join("")},base64ToBytes:function(t){t=t.replace(/[^A-Z0-9+\/]/gi,"");for(var n=[],r=0,o=0;r<t.length;o=++r%4)0!=o&&n.push((e.indexOf(t.charAt(r-1))&Math.pow(2,-2*o+8)-1)<<2*o|e.indexOf(t.charAt(r))>>>6-2*o);return n}};t.exports=n}()},function(t,e){function n(t){return!!t.constructor&&"function"==typeof t.constructor.isBuffer&&t.constructor.isBuffer(t)}function r(t){return"function"==typeof t.readFloatLE&&"function"==typeof t.slice&&n(t.slice(0,0))}/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
t.exports=function(t){return null!=t&&(n(t)||r(t)||!!t._isBuffer)}},function(t,e,n){/*!
  * domready (c) Dustin Diaz 2014 - License MIT
  */
!function(e,n){t.exports=n()}(0,function(){var t,e=[],n=document,r=n.documentElement.doScroll,o=(r?/^loaded|^c/:/^loaded|^i|^c/).test(n.readyState);return o||n.addEventListener("DOMContentLoaded",t=function(){for(n.removeEventListener("DOMContentLoaded",t),o=1;t=e.shift();)t()}),function(t){o?setTimeout(t,0):e.push(t)}})},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=n(15),o=n(7),i=n(16),a=function(t,e,n){function a(o,u,s){function l(t,e){t[e]--}if(u){var c={};c[u.nodeName]=1;for(var p=u,f=u.nextSibling;f;){var m=f.nodeName;c[m]=c[m]?c[m]+1:1,p=f,f=f.nextSibling}u=p;for(var g=!0,v=u&&u.previousSibling;;){if(g?g=!1:(u=v,v=u&&u.previousSibling),!u)break;if(u===h)return;if(t.filter(u,o)||u.id&&u.id===r.default.WIDGET_ID)l(c,u.nodeName);else{var y=!1,w=s||i.default.isIdentifiableThirdPartyNode(u),m=u.nodeName,b=void 0;if("#text"===m){if(/^\s+$/.test(u.nodeValue)){l(c,m);continue}b="text()"}else b=m.toLowerCase();var x=c[m]>1?"["+c[m]+"]":"",O=o+"/"+b+x;if(t.target(u,O)&&0!==t.limit&&(y=e(u,O,w),--t.limit),n(u,O,w),0===t.limit)return;if(u.hasChildNodes()&&!y&&a(O,u.firstChild,w),"IFRAME"===m){var E=null;try{E=u.contentDocument}catch(t){}E&&a("",E.firstChild,w)}if(d&&u.hasAttribute)for(var T in d)if(u.hasAttribute(T)&&0!==t.limit){var O=o+"/"+u.nodeName+"[@"+T+"]"+x;d[T](u,O),--t.limit}l(c,m)}}}}if("function"==typeof e&&"function"==typeof n){var u,s,l={head:document.head||document.getElementsByTagName("head")[0],limit:-1,filter:function(t){return t.nodeName.toLowerCase().match(/script|noscript|style/)},target:function(t){return"#comment"!==t.nodeName}};if(t.hasOwnProperty("head")&&t.head&&(s=t.head,(u=o.default.getXpath(s))&&(u="#text"===s.nodeName?u.replace(/\/text\(\)$/,""):u.replace(new RegExp("/"+s.nodeName.toLowerCase()+"$"),""))),u||(s=l.head,u="/html"),t.hasOwnProperty("headXPath")&&"string"==typeof t.headParentXpath||(t.headParentXpath=l.headParentXpath),t.hasOwnProperty("limit")&&"number"==typeof t.limit?t.limit=Math.floor(t.limit):t.limit=l.limit,0!==t.limit){if(t.hasOwnProperty("filter")?"function"==typeof t.filter||("object"==typeof t.filter&&t.filter.nodeName?t.filter=function(t){return function(e){return e.nodeName.toLowerCase().match(/script|noscript|style/)||e.nodeName.toLowerCase()===t}}(t.filter.nodeName.toLowerCase()):"string"==typeof t.filter?t.filter=function(t){return function(e){return e.nodeName.toLowerCase().match(/script|noscript|style/)||e.nodeName.toLowerCase()===t}}(t.filter.toLowerCase()):t.filter=l.filter):t.filter=l.filter,t.hasOwnProperty("target")&&"function"!=typeof t.target)if("object"==typeof t.target&&t.target.length){for(var c="",p=0;p<t.target.length;p++)c+=(t.target[p].nodeName||t.target[p])+"|";c="^("+c.substr(0,c.length-1)+")$";var f=new RegExp(c,"i");t.target=function(t){return function(e){return t.test(e.nodeName)}}(f)}else"object"==typeof t.target&&t.target.nodeName?t.target=function(t){return function(e){return e.nodeName.toLowerCase()===t}}(t.target.nodeName.toLowerCase()):"string"==typeof t.target?t.target=function(t){return function(e){return e.nodeName.toLowerCase()===t}}(t.target.toLowerCase()):t.target=l.target;else t.target=l.target;var d=t.attributes,h=(document.head||document.getElementsByTagName("head")[0]).parentElement;a(u,s,!!s.parent&&i.default.isIdentifiableThirdPartyNode(s.parent))}}};e.default={go:a}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default={WIDGET_ID:"wovn-translate-widget"}},function(t,e,n){"use strict";function r(t,e,n){this.name=t,this.attr=e,this.val=n,this.matchesElement=function(t){return(!this.name||t.nodeName===this.name)&&t.getAttribute(this.attr)===this.val}}Object.defineProperty(e,"__esModule",{value:!0});var o=[new r("DIV","id","intercom-container"),new r("IFRAME","id","intercom-frame"),new r("DIV","class","gm-style"),new r("IFRAME","id","pop-veritrans")],i=function(t){if(t&&1==t.nodeType)for(var e=0;e<o.length;++e)if(o[e].matchesElement(t))return!0;return!1};e.default={isIdentifiableThirdPartyNode:i}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=function(){function t(){}return t.prototype.getUrlFromCss=function(t){t=t.split(",")[0];var e=/^url\(["']?([^"']+?)["']?\)?$/.exec(t);return e?e[1]:null},t}();e.default=r},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=function(){function t(t){void 0===t&&(t=1e3),this.coolDownTime=t,this.workableId=0,this.isExecuting=!1,this.previousExecutedTime=null}return t.prototype.isCoolingDown=function(t){return this.previousExecutedTime&&this.previousExecutedTime+this.coolDownTime>t},t.prototype.executeSetTimeout=function(t,e,n,r,o){var i=this,a=function(n,r){n===i.workableId&&(i.isExecuting=!0,i.previousExecutedTime=null,t.apply(i,r),i.previousExecutedTime=(new Date).getTime(),i.isExecuting=!1,e())};!function(t,e){setTimeout(function(){a(t,e)},n)}(r,o)},t.prototype.createSingleWorker=function(e){return void 0===e&&(e=1e3),new t(e)},t.prototype.setTimeout=function(t,e,n){var r=(new Date).getTime();if(!this.isExecuting){if(this.isCoolingDown(r)){var o=this.previousExecutedTime+this.coolDownTime;n=Math.max(o+100,n+r)-r}this.workableId=(this.workableId+1)%1e4;var i=Array.prototype.slice.call(arguments).slice(3);this.executeSetTimeout(t,e,n,this.workableId,i)}},t}();e.default=new r},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=function(){function t(){}return t.prototype.init=function(){var t=document.createElement("script");t.async=!0,t.src="//wap.wovn.io/1.js",document.getElementsByTagName("head")[0].appendChild(t)},t}();e.default=new r}]);


/** Starts initialization if there is not a wovn-ignore attribute in the <html> tag. */
function kickoffWidgetInit () {
  var htmlTag = document.getElementsByTagName('html')[0];
  if (!htmlTag || (htmlTag.getAttribute('wovn-ignore') === null))
    widget.c('Interface').start(function () {
      widget.c('SwapIntercom').start();
    });
  else
    if(console && console.log) console.log("WOVN DISABLED");

    widget.c('Wap').init();
}

function kickoffLiveEditorInit () {
  var componentsToLoad = ['Vue', 'LiveEditorController', 'LiveEditorDecorator']
  var loadedComponents = {}
  var loadedCallbacks = {}

  function allComponentsLoaded () {
    return componentsToLoad.every(function (componentName) {
      return loadedComponents[componentName]
    })
  }

  function kickoffLiveEditor (event) {
    var componentName = event.type.replace(/Loaded$/, '')

    loadedComponents[componentName] = true

    if (allComponentsLoaded()) {
      widget.c('Api')
      widget.c('LiveEditorDecorator').start()
    }
  }

  for (var i = 0; i < componentsToLoad.length; ++i) {
    loadedCallbacks[componentsToLoad[i]] = kickoffLiveEditor
  }

  widget.loadComponents(componentsToLoad, loadedCallbacks)
}

if (widget.c('Url').isIframeLiveEditor()) {
  kickoffLiveEditorInit();
}
else {
  kickoffWidgetInit();
}

}());
